{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RandomNumbers.jl Documentation RandomNumbers.jl is a collection of Random Number Generators for the Julia language. There are several kinds of RNG families in this package, provided as submodules. The examples and detailed descriptions of each RNG can be found on the Manual pages. Manual Outline Basics Installation Interface Empirical Statistical Testing Conversion to Float Benchmark Speed Test Big Crush Test PCG Family PCG Type PCG Method Type Interface and Examples Mersenne Twisters Examples Random123 Family Random123 RNGs Examples Xorshift Family Examples Library Outline RandomNumbers Index Common Functions Public Internal PCG Index Public Internal MersenneTwisters Index Public Internal Random123 Index Public Internal Xorshifts Index Public Internal","title":"Home"},{"location":"#randomnumbersjl-documentation","text":"RandomNumbers.jl is a collection of Random Number Generators for the Julia language. There are several kinds of RNG families in this package, provided as submodules. The examples and detailed descriptions of each RNG can be found on the Manual pages.","title":"RandomNumbers.jl Documentation"},{"location":"#manual-outline","text":"Basics Installation Interface Empirical Statistical Testing Conversion to Float Benchmark Speed Test Big Crush Test PCG Family PCG Type PCG Method Type Interface and Examples Mersenne Twisters Examples Random123 Family Random123 RNGs Examples Xorshift Family Examples","title":"Manual Outline"},{"location":"#library-outline","text":"RandomNumbers Index Common Functions Public Internal PCG Index Public Internal MersenneTwisters Index Public Internal Random123 Index Public Internal Xorshifts Index Public Internal","title":"Library Outline"},{"location":"lib/mersenne-twisters/","text":"MersenneTwisters Index RandomNumbers.MersenneTwisters RandomNumbers.MersenneTwisters.MT19937 RandomNumbers.MersenneTwisters.MersenneTwister RandomNumbers.MersenneTwisters.mt_get RandomNumbers.MersenneTwisters.mt_set! RandomNumbers.MersenneTwisters.mt_set! Public # RandomNumbers.MersenneTwisters \u2014 Module . The module for Mersenne Twisters . Currently only provide one RNG type: MT19937 source # RandomNumbers.MersenneTwisters.MT19937 \u2014 Type . MT19937 <: MersenneTwister { UInt32 } MT19937 ([ seed ]) MT19937 RNG. The seed is a Tuple of 624 UInt32 numbers, or an Integer which will be automatically convert to an UInt32 number. source Internal # RandomNumbers.MersenneTwisters.MersenneTwister \u2014 Type . MersenneTwister { T } <: AbstractRNG { T } The base type of Mersenne Twisters. source # RandomNumbers.MersenneTwisters.mt_get \u2014 Method . Get a random UInt32 number from a MT19937 object. source # RandomNumbers.MersenneTwisters.mt_set! \u2014 Method . Set up a MT19937 RNG object using a Tuple of 624 UInt32 numbers. source # RandomNumbers.MersenneTwisters.mt_set! \u2014 Method . Set up a MT19937 RNG object using an UInt32 number. source","title":"MersenneTwisters"},{"location":"lib/mersenne-twisters/#mersennetwisters","text":"","title":"MersenneTwisters"},{"location":"lib/mersenne-twisters/#index","text":"RandomNumbers.MersenneTwisters RandomNumbers.MersenneTwisters.MT19937 RandomNumbers.MersenneTwisters.MersenneTwister RandomNumbers.MersenneTwisters.mt_get RandomNumbers.MersenneTwisters.mt_set! RandomNumbers.MersenneTwisters.mt_set!","title":"Index"},{"location":"lib/mersenne-twisters/#public","text":"# RandomNumbers.MersenneTwisters \u2014 Module . The module for Mersenne Twisters . Currently only provide one RNG type: MT19937 source # RandomNumbers.MersenneTwisters.MT19937 \u2014 Type . MT19937 <: MersenneTwister { UInt32 } MT19937 ([ seed ]) MT19937 RNG. The seed is a Tuple of 624 UInt32 numbers, or an Integer which will be automatically convert to an UInt32 number. source","title":"Public"},{"location":"lib/mersenne-twisters/#internal","text":"# RandomNumbers.MersenneTwisters.MersenneTwister \u2014 Type . MersenneTwister { T } <: AbstractRNG { T } The base type of Mersenne Twisters. source # RandomNumbers.MersenneTwisters.mt_get \u2014 Method . Get a random UInt32 number from a MT19937 object. source # RandomNumbers.MersenneTwisters.mt_set! \u2014 Method . Set up a MT19937 RNG object using a Tuple of 624 UInt32 numbers. source # RandomNumbers.MersenneTwisters.mt_set! \u2014 Method . Set up a MT19937 RNG object using an UInt32 number. source","title":"Internal"},{"location":"lib/pcg/","text":"PCG Index RandomNumbers.PCG RandomNumbers.PCG.PCG_LIST RandomNumbers.PCG.AbstractPCG RandomNumbers.PCG.PCGMethod RandomNumbers.PCG.PCGStateMCG RandomNumbers.PCG.PCGStateOneseq RandomNumbers.PCG.PCGStateSetseq RandomNumbers.PCG.PCGStateUnique RandomNumbers.PCG.PCG_RXS_M_XS RandomNumbers.PCG.PCG_XSH_RR RandomNumbers.PCG.PCG_XSH_RS RandomNumbers.PCG.PCG_XSL_RR RandomNumbers.PCG.PCG_XSL_RR_RR RandomNumbers.PCG.advance! RandomNumbers.PCG.bounded_rand RandomNumbers.PCG.default_increment RandomNumbers.PCG.default_multiplier RandomNumbers.PCG.mcg_multiplier RandomNumbers.PCG.mcg_unmultiplier RandomNumbers.PCG.pcg_advance! RandomNumbers.PCG.pcg_advance_lcg RandomNumbers.PCG.pcg_output RandomNumbers.PCG.pcg_seed! RandomNumbers.PCG.pcg_step! Public # RandomNumbers.PCG \u2014 Module . The module for PCG Family . source # RandomNumbers.PCG.PCGMethod \u2014 Type . The Union of all the PCG method types: PCG_XSH_RS , PCG_XSH_RR , PCG_RXS_M_XS , PCG_XSL_RR , and PCG_XSL_RR_RR . source # RandomNumbers.PCG.PCG_LIST \u2014 Constant . The list of all the parameter combinations that can be used for PCG. Stream variation State Type Method Type Output Type PCGStateOneseq UInt16 PCG_XSH_RS UInt8 PCGStateOneseq UInt32 PCG_XSH_RS UInt16 PCGStateOneseq UInt64 PCG_XSH_RS UInt32 PCGStateOneseq UInt128 PCG_XSH_RS UInt64 PCGStateUnique UInt16 PCG_XSH_RS UInt8 PCGStateUnique UInt32 PCG_XSH_RS UInt16 PCGStateUnique UInt64 PCG_XSH_RS UInt32 PCGStateUnique UInt128 PCG_XSH_RS UInt64 PCGStateSetseq UInt16 PCG_XSH_RS UInt8 PCGStateSetseq UInt32 PCG_XSH_RS UInt16 PCGStateSetseq UInt64 PCG_XSH_RS UInt32 PCGStateSetseq UInt128 PCG_XSH_RS UInt64 PCGStateMCG UInt16 PCG_XSH_RS UInt8 PCGStateMCG UInt32 PCG_XSH_RS UInt16 PCGStateMCG UInt64 PCG_XSH_RS UInt32 PCGStateMCG UInt128 PCG_XSH_RS UInt64 PCGStateOneseq UInt16 PCG_XSH_RR UInt8 PCGStateOneseq UInt32 PCG_XSH_RR UInt16 PCGStateOneseq UInt64 PCG_XSH_RR UInt32 PCGStateOneseq UInt128 PCG_XSH_RR UInt64 PCGStateUnique UInt16 PCG_XSH_RR UInt8 PCGStateUnique UInt32 PCG_XSH_RR UInt16 PCGStateUnique UInt64 PCG_XSH_RR UInt32 PCGStateUnique UInt128 PCG_XSH_RR UInt64 PCGStateSetseq UInt16 PCG_XSH_RR UInt8 PCGStateSetseq UInt32 PCG_XSH_RR UInt16 PCGStateSetseq UInt64 PCG_XSH_RR UInt32 PCGStateSetseq UInt128 PCG_XSH_RR UInt64 PCGStateMCG UInt16 PCG_XSH_RR UInt8 PCGStateMCG UInt32 PCG_XSH_RR UInt16 PCGStateMCG UInt64 PCG_XSH_RR UInt32 PCGStateMCG UInt128 PCG_XSH_RR UInt64 PCGStateOneseq UInt8 PCG_RXS_M_XS UInt8 PCGStateOneseq UInt16 PCG_RXS_M_XS UInt16 PCGStateOneseq UInt32 PCG_RXS_M_XS UInt32 PCGStateOneseq UInt64 PCG_RXS_M_XS UInt64 PCGStateOneseq UInt128 PCG_RXS_M_XS UInt128 PCGStateUnique UInt16 PCG_RXS_M_XS UInt16 PCGStateUnique UInt32 PCG_RXS_M_XS UInt32 PCGStateUnique UInt64 PCG_RXS_M_XS UInt64 PCGStateUnique UInt128 PCG_RXS_M_XS UInt128 PCGStateSetseq UInt8 PCG_RXS_M_XS UInt8 PCGStateSetseq UInt16 PCG_RXS_M_XS UInt16 PCGStateSetseq UInt32 PCG_RXS_M_XS UInt32 PCGStateSetseq UInt64 PCG_RXS_M_XS UInt64 PCGStateSetseq UInt128 PCG_RXS_M_XS UInt128 PCGStateOneseq UInt64 PCG_XSL_RR UInt32 PCGStateOneseq UInt128 PCG_XSL_RR UInt64 PCGStateUnique UInt64 PCG_XSL_RR UInt32 PCGStateUnique UInt128 PCG_XSL_RR UInt64 PCGStateSetseq UInt64 PCG_XSL_RR UInt32 PCGStateSetseq UInt128 PCG_XSL_RR UInt64 PCGStateMCG UInt64 PCG_XSL_RR UInt32 PCGStateMCG UInt128 PCG_XSL_RR UInt64 PCGStateOneseq UInt64 PCG_XSL_RR_RR UInt64 PCGStateOneseq UInt128 PCG_XSL_RR_RR UInt128 PCGStateUnique UInt64 PCG_XSL_RR_RR UInt64 PCGStateUnique UInt128 PCG_XSL_RR_RR UInt128 PCGStateSetseq UInt64 PCG_XSL_RR_RR UInt64 PCGStateSetseq UInt128 PCG_XSL_RR_RR UInt128 source # RandomNumbers.PCG.PCGStateMCG \u2014 Type . PCGStateMCG { StateType <: PCGUInt , MethodType <: PCGMethod , OutputType <: PCGUInt } <: AbstractPCG { StateType , MethodType , OutputType } PCGStateMCG ([ seed ]) PCGStateMCG ( output_type [, seed ]) PCGStateMCG ( method [, seed ]) PCGStateMCG ( output_type [, method , seed ]) PCG generator with MCG , where the increment is zero, resulting in a single stream and reduced period. seed is an Integer which will be automatically converted to the state type. output_type is the type of the PCG's output. If missing it is set to UInt64 . method is one of the PCGMethod . If missing it is set to PCG_XSH_RS . See PCG_LIST for the available parameter combinations. source # RandomNumbers.PCG.PCGStateOneseq \u2014 Type . PCGStateOneseq { StateType <: PCGUInt , MethodType <: PCGMethod , OutputType <: PCGUInt } <: AbstractPCG { StateType , MethodType , OutputType } PCGStateOneseq ([ seed ]) PCGStateOneseq ( output_type [, seed ]) PCGStateOneseq ( method [, seed ]) PCGStateOneseq ( output_type [, method , seed ]) PCG generator with single streams , where all instances use the same fixed constant, thus the RNG always somewhere in same sequence. seed is an Integer which will be automatically converted to the state type. output_type is the type of the PCG's output. If missing it is set to UInt64 . method is one of the PCGMethod . If missing it is set to PCG_XSH_RS . See PCG_LIST for the available parameter combinations. source # RandomNumbers.PCG.PCGStateSetseq \u2014 Type . PCGStateSetseq { StateType <: PCGUInt , MethodType <: PCGMethod , OutputType <: PCGUInt } <: AbstractPCG { StateType , MethodType , OutputType } PCGStateSetseq ([ seed ]) PCGStateSetseq ( output_type [, seed ]) PCGStateSetseq ( method [, seed ]) PCGStateSetseq ( output_type [, method , seed ]) PCG generator with specific streams , where the constant can be changed at any time, selecting a different random sequence. seed is a Tuple of two Integer s which will both be automatically converted to the state type. output_type is the type of the PCG's output. If missing it is set to UInt64 . method is one of the PCGMethod . If missing it is set to PCG_XSH_RS . See PCG_LIST for the available parameter combinations. source # RandomNumbers.PCG.PCGStateUnique \u2014 Type . PCGStateUnique { StateType <: PCGUInt , MethodType <: PCGMethod , OutputType <: PCGUInt } <: AbstractPCG { StateType , MethodType , OutputType } PCGStateUnique ([ seed ]) PCGStateUnique ( output_type [, seed ]) PCGStateUnique ( method [, seed ]) PCGStateUnique ( output_type [, method , seed ]) PCG generator with unique streams , where the constant is based on the memory address of the object, thus every RNG has its own unique sequence. seed is an Integer which will be automatically converted to the state type. output_type is the type of the PCG's output. If missing it is set to UInt64 . method is one of the PCGMethod . If missing it is set to PCG_XSH_RS . See PCG_LIST for the available parameter combinations. source # RandomNumbers.PCG.PCG_RXS_M_XS \u2014 Type . One of PCG output method: random xorshift, mcg multiply, fixed xorshift. The most statistically powerful generator, but slower than some of the others. source # RandomNumbers.PCG.PCG_XSH_RR \u2014 Type . One of PCG output method: high xorshift, followed by a random rotate. Fast. Slightly better statistically than PCG_XSH_RS . source # RandomNumbers.PCG.PCG_XSH_RS \u2014 Type . One of PCG output method: high xorshift, followed by a random shift. Fast. source # RandomNumbers.PCG.PCG_XSL_RR \u2014 Type . One of PCG output method: fixed xorshift (to low bits), random rotate. Useful for 128-bit types that are split across two CPU registers. source # RandomNumbers.PCG.PCG_XSL_RR_RR \u2014 Type . One of PCG output method: fixed xorshift (to low bits), random rotate (both parts). Useful for 128-bit types that are split across two CPU registers. Use this in need of an invertable 128-bit RNG. source <a id='RandomNumbers.PCG.advance!-Union{Tuple{StateType}, Tuple{RandomNumbers.PCG.AbstractPCG{StateType, MethodType, OutputType} where {MethodType<:Union{Val{:XSH_RS}, Val{:XSH_RR}, Val{:RXS_M_XS}, Val{:XSL_RR}, Val{:XSL_RR_RR}}, OutputType<:Union{UInt128, UInt16, UInt32, UInt64, UInt8}}, Integer}} where StateType<:Union{UInt128, UInt16, UInt32, UInt64, UInt8}' href='#RandomNumbers.PCG.advance!-Union{Tuple{StateType}, Tuple{RandomNumbers.PCG.AbstractPCG{StateType, MethodType, OutputType} where {MethodType<:Union{Val{:XSH_RS}, Val{:XSH_RR}, Val{:RXS_M_XS}, Val{:XSL_RR}, Val{:XSL_RR_RR}}, OutputType<:Union{UInt128, UInt16, UInt32, UInt64, UInt8}}, Integer}} where StateType<:Union{UInt128, UInt16, UInt32, UInt64, UInt8}'># RandomNumbers.PCG.advance! \u2014 Method . advance! ( r , \u0394 ) Advance a PCG object r for \u0394 steps. Examples julia> r = PCGStateSetseq ( UInt64 , PCG_RXS_M_XS , ( 123 , 321 )) PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x45389f8b27528b29, 0x0000000000000283) julia> A = rand ( r , UInt64 , 2 ); julia> p = rand ( r ); julia> r PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x9b1fc763ae0ad702, 0x0000000000000283) julia> advance! ( r , - 3 ) PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x45389f8b27528b29, 0x0000000000000283) julia> @Test . test A == rand ( r , UInt64 , 2 ) Test Passed julia> @Test . test p == rand ( r ) Test Passed source <a id='RandomNumbers.PCG.bounded_rand-Union{Tuple{OutputType}, Tuple{MethodType}, Tuple{StateType}, Tuple{RandomNumbers.PCG.AbstractPCG{StateType, MethodType, OutputType}, OutputType}} where {StateType<:Union{UInt128, UInt16, UInt32, UInt64, UInt8}, MethodType<:Union{Val{:XSH_RS}, Val{:XSH_RR}, Val{:RXS_M_XS}, Val{:XSL_RR}, Val{:XSL_RR_RR}}, OutputType<:Union{UInt128, UInt16, UInt32, UInt64, UInt8}}' href='#RandomNumbers.PCG.bounded_rand-Union{Tuple{OutputType}, Tuple{MethodType}, Tuple{StateType}, Tuple{RandomNumbers.PCG.AbstractPCG{StateType, MethodType, OutputType}, OutputType}} where {StateType<:Union{UInt128, UInt16, UInt32, UInt64, UInt8}, MethodType<:Union{Val{:XSH_RS}, Val{:XSH_RR}, Val{:RXS_M_XS}, Val{:XSL_RR}, Val{:XSL_RR_RR}}, OutputType<:Union{UInt128, UInt16, UInt32, UInt64, UInt8}}'># RandomNumbers.PCG.bounded_rand \u2014 Method . bounded_rand ( r , bound ) Producing a random number less than a given bound in the output type. source Internal # RandomNumbers.PCG.AbstractPCG \u2014 Type . AbstractPCG { StateType <: PCGUInt , MethodType <: PCGMethod , OutputType <: PCGUInt } <: AbstractRNG { OutputType } The base abstract type for PCGs. source # RandomNumbers.PCG.default_increment \u2014 Method . Return the default increment for a certain type. source # RandomNumbers.PCG.default_multiplier \u2014 Method . Return the default multiplier for a certain type. source # RandomNumbers.PCG.mcg_multiplier \u2014 Method . Return the default MCG multiplier for a certain type. source # RandomNumbers.PCG.mcg_unmultiplier \u2014 Method . Return the default MCG unmultiplier for a certain type. source # RandomNumbers.PCG.pcg_advance! \u2014 Function . Advance a PCG object. source <a id='RandomNumbers.PCG.pcg_advance_lcg-Union{Tuple{T}, NTuple{4, T}} where T<:Union{UInt128, UInt16, UInt32, UInt64, UInt8}' href='#RandomNumbers.PCG.pcg_advance_lcg-Union{Tuple{T}, NTuple{4, T}} where T<:Union{UInt128, UInt16, UInt32, UInt64, UInt8}'># RandomNumbers.PCG.pcg_advance_lcg \u2014 Method . General advance functions. source # RandomNumbers.PCG.pcg_output \u2014 Function . Return the output of a state for a certain PCG type. source # RandomNumbers.PCG.pcg_seed! \u2014 Function . Initialize a PCG object. source # RandomNumbers.PCG.pcg_step! \u2014 Function . Do one iteration step for a PCG object. source","title":"PCG"},{"location":"lib/pcg/#pcg","text":"","title":"PCG"},{"location":"lib/pcg/#index","text":"RandomNumbers.PCG RandomNumbers.PCG.PCG_LIST RandomNumbers.PCG.AbstractPCG RandomNumbers.PCG.PCGMethod RandomNumbers.PCG.PCGStateMCG RandomNumbers.PCG.PCGStateOneseq RandomNumbers.PCG.PCGStateSetseq RandomNumbers.PCG.PCGStateUnique RandomNumbers.PCG.PCG_RXS_M_XS RandomNumbers.PCG.PCG_XSH_RR RandomNumbers.PCG.PCG_XSH_RS RandomNumbers.PCG.PCG_XSL_RR RandomNumbers.PCG.PCG_XSL_RR_RR RandomNumbers.PCG.advance! RandomNumbers.PCG.bounded_rand RandomNumbers.PCG.default_increment RandomNumbers.PCG.default_multiplier RandomNumbers.PCG.mcg_multiplier RandomNumbers.PCG.mcg_unmultiplier RandomNumbers.PCG.pcg_advance! RandomNumbers.PCG.pcg_advance_lcg RandomNumbers.PCG.pcg_output RandomNumbers.PCG.pcg_seed! RandomNumbers.PCG.pcg_step!","title":"Index"},{"location":"lib/pcg/#public","text":"# RandomNumbers.PCG \u2014 Module . The module for PCG Family . source # RandomNumbers.PCG.PCGMethod \u2014 Type . The Union of all the PCG method types: PCG_XSH_RS , PCG_XSH_RR , PCG_RXS_M_XS , PCG_XSL_RR , and PCG_XSL_RR_RR . source # RandomNumbers.PCG.PCG_LIST \u2014 Constant . The list of all the parameter combinations that can be used for PCG. Stream variation State Type Method Type Output Type PCGStateOneseq UInt16 PCG_XSH_RS UInt8 PCGStateOneseq UInt32 PCG_XSH_RS UInt16 PCGStateOneseq UInt64 PCG_XSH_RS UInt32 PCGStateOneseq UInt128 PCG_XSH_RS UInt64 PCGStateUnique UInt16 PCG_XSH_RS UInt8 PCGStateUnique UInt32 PCG_XSH_RS UInt16 PCGStateUnique UInt64 PCG_XSH_RS UInt32 PCGStateUnique UInt128 PCG_XSH_RS UInt64 PCGStateSetseq UInt16 PCG_XSH_RS UInt8 PCGStateSetseq UInt32 PCG_XSH_RS UInt16 PCGStateSetseq UInt64 PCG_XSH_RS UInt32 PCGStateSetseq UInt128 PCG_XSH_RS UInt64 PCGStateMCG UInt16 PCG_XSH_RS UInt8 PCGStateMCG UInt32 PCG_XSH_RS UInt16 PCGStateMCG UInt64 PCG_XSH_RS UInt32 PCGStateMCG UInt128 PCG_XSH_RS UInt64 PCGStateOneseq UInt16 PCG_XSH_RR UInt8 PCGStateOneseq UInt32 PCG_XSH_RR UInt16 PCGStateOneseq UInt64 PCG_XSH_RR UInt32 PCGStateOneseq UInt128 PCG_XSH_RR UInt64 PCGStateUnique UInt16 PCG_XSH_RR UInt8 PCGStateUnique UInt32 PCG_XSH_RR UInt16 PCGStateUnique UInt64 PCG_XSH_RR UInt32 PCGStateUnique UInt128 PCG_XSH_RR UInt64 PCGStateSetseq UInt16 PCG_XSH_RR UInt8 PCGStateSetseq UInt32 PCG_XSH_RR UInt16 PCGStateSetseq UInt64 PCG_XSH_RR UInt32 PCGStateSetseq UInt128 PCG_XSH_RR UInt64 PCGStateMCG UInt16 PCG_XSH_RR UInt8 PCGStateMCG UInt32 PCG_XSH_RR UInt16 PCGStateMCG UInt64 PCG_XSH_RR UInt32 PCGStateMCG UInt128 PCG_XSH_RR UInt64 PCGStateOneseq UInt8 PCG_RXS_M_XS UInt8 PCGStateOneseq UInt16 PCG_RXS_M_XS UInt16 PCGStateOneseq UInt32 PCG_RXS_M_XS UInt32 PCGStateOneseq UInt64 PCG_RXS_M_XS UInt64 PCGStateOneseq UInt128 PCG_RXS_M_XS UInt128 PCGStateUnique UInt16 PCG_RXS_M_XS UInt16 PCGStateUnique UInt32 PCG_RXS_M_XS UInt32 PCGStateUnique UInt64 PCG_RXS_M_XS UInt64 PCGStateUnique UInt128 PCG_RXS_M_XS UInt128 PCGStateSetseq UInt8 PCG_RXS_M_XS UInt8 PCGStateSetseq UInt16 PCG_RXS_M_XS UInt16 PCGStateSetseq UInt32 PCG_RXS_M_XS UInt32 PCGStateSetseq UInt64 PCG_RXS_M_XS UInt64 PCGStateSetseq UInt128 PCG_RXS_M_XS UInt128 PCGStateOneseq UInt64 PCG_XSL_RR UInt32 PCGStateOneseq UInt128 PCG_XSL_RR UInt64 PCGStateUnique UInt64 PCG_XSL_RR UInt32 PCGStateUnique UInt128 PCG_XSL_RR UInt64 PCGStateSetseq UInt64 PCG_XSL_RR UInt32 PCGStateSetseq UInt128 PCG_XSL_RR UInt64 PCGStateMCG UInt64 PCG_XSL_RR UInt32 PCGStateMCG UInt128 PCG_XSL_RR UInt64 PCGStateOneseq UInt64 PCG_XSL_RR_RR UInt64 PCGStateOneseq UInt128 PCG_XSL_RR_RR UInt128 PCGStateUnique UInt64 PCG_XSL_RR_RR UInt64 PCGStateUnique UInt128 PCG_XSL_RR_RR UInt128 PCGStateSetseq UInt64 PCG_XSL_RR_RR UInt64 PCGStateSetseq UInt128 PCG_XSL_RR_RR UInt128 source # RandomNumbers.PCG.PCGStateMCG \u2014 Type . PCGStateMCG { StateType <: PCGUInt , MethodType <: PCGMethod , OutputType <: PCGUInt } <: AbstractPCG { StateType , MethodType , OutputType } PCGStateMCG ([ seed ]) PCGStateMCG ( output_type [, seed ]) PCGStateMCG ( method [, seed ]) PCGStateMCG ( output_type [, method , seed ]) PCG generator with MCG , where the increment is zero, resulting in a single stream and reduced period. seed is an Integer which will be automatically converted to the state type. output_type is the type of the PCG's output. If missing it is set to UInt64 . method is one of the PCGMethod . If missing it is set to PCG_XSH_RS . See PCG_LIST for the available parameter combinations. source # RandomNumbers.PCG.PCGStateOneseq \u2014 Type . PCGStateOneseq { StateType <: PCGUInt , MethodType <: PCGMethod , OutputType <: PCGUInt } <: AbstractPCG { StateType , MethodType , OutputType } PCGStateOneseq ([ seed ]) PCGStateOneseq ( output_type [, seed ]) PCGStateOneseq ( method [, seed ]) PCGStateOneseq ( output_type [, method , seed ]) PCG generator with single streams , where all instances use the same fixed constant, thus the RNG always somewhere in same sequence. seed is an Integer which will be automatically converted to the state type. output_type is the type of the PCG's output. If missing it is set to UInt64 . method is one of the PCGMethod . If missing it is set to PCG_XSH_RS . See PCG_LIST for the available parameter combinations. source # RandomNumbers.PCG.PCGStateSetseq \u2014 Type . PCGStateSetseq { StateType <: PCGUInt , MethodType <: PCGMethod , OutputType <: PCGUInt } <: AbstractPCG { StateType , MethodType , OutputType } PCGStateSetseq ([ seed ]) PCGStateSetseq ( output_type [, seed ]) PCGStateSetseq ( method [, seed ]) PCGStateSetseq ( output_type [, method , seed ]) PCG generator with specific streams , where the constant can be changed at any time, selecting a different random sequence. seed is a Tuple of two Integer s which will both be automatically converted to the state type. output_type is the type of the PCG's output. If missing it is set to UInt64 . method is one of the PCGMethod . If missing it is set to PCG_XSH_RS . See PCG_LIST for the available parameter combinations. source # RandomNumbers.PCG.PCGStateUnique \u2014 Type . PCGStateUnique { StateType <: PCGUInt , MethodType <: PCGMethod , OutputType <: PCGUInt } <: AbstractPCG { StateType , MethodType , OutputType } PCGStateUnique ([ seed ]) PCGStateUnique ( output_type [, seed ]) PCGStateUnique ( method [, seed ]) PCGStateUnique ( output_type [, method , seed ]) PCG generator with unique streams , where the constant is based on the memory address of the object, thus every RNG has its own unique sequence. seed is an Integer which will be automatically converted to the state type. output_type is the type of the PCG's output. If missing it is set to UInt64 . method is one of the PCGMethod . If missing it is set to PCG_XSH_RS . See PCG_LIST for the available parameter combinations. source # RandomNumbers.PCG.PCG_RXS_M_XS \u2014 Type . One of PCG output method: random xorshift, mcg multiply, fixed xorshift. The most statistically powerful generator, but slower than some of the others. source # RandomNumbers.PCG.PCG_XSH_RR \u2014 Type . One of PCG output method: high xorshift, followed by a random rotate. Fast. Slightly better statistically than PCG_XSH_RS . source # RandomNumbers.PCG.PCG_XSH_RS \u2014 Type . One of PCG output method: high xorshift, followed by a random shift. Fast. source # RandomNumbers.PCG.PCG_XSL_RR \u2014 Type . One of PCG output method: fixed xorshift (to low bits), random rotate. Useful for 128-bit types that are split across two CPU registers. source # RandomNumbers.PCG.PCG_XSL_RR_RR \u2014 Type . One of PCG output method: fixed xorshift (to low bits), random rotate (both parts). Useful for 128-bit types that are split across two CPU registers. Use this in need of an invertable 128-bit RNG. source <a id='RandomNumbers.PCG.advance!-Union{Tuple{StateType}, Tuple{RandomNumbers.PCG.AbstractPCG{StateType, MethodType, OutputType} where {MethodType<:Union{Val{:XSH_RS}, Val{:XSH_RR}, Val{:RXS_M_XS}, Val{:XSL_RR}, Val{:XSL_RR_RR}}, OutputType<:Union{UInt128, UInt16, UInt32, UInt64, UInt8}}, Integer}} where StateType<:Union{UInt128, UInt16, UInt32, UInt64, UInt8}' href='#RandomNumbers.PCG.advance!-Union{Tuple{StateType}, Tuple{RandomNumbers.PCG.AbstractPCG{StateType, MethodType, OutputType} where {MethodType<:Union{Val{:XSH_RS}, Val{:XSH_RR}, Val{:RXS_M_XS}, Val{:XSL_RR}, Val{:XSL_RR_RR}}, OutputType<:Union{UInt128, UInt16, UInt32, UInt64, UInt8}}, Integer}} where StateType<:Union{UInt128, UInt16, UInt32, UInt64, UInt8}'># RandomNumbers.PCG.advance! \u2014 Method . advance! ( r , \u0394 ) Advance a PCG object r for \u0394 steps. Examples julia> r = PCGStateSetseq ( UInt64 , PCG_RXS_M_XS , ( 123 , 321 )) PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x45389f8b27528b29, 0x0000000000000283) julia> A = rand ( r , UInt64 , 2 ); julia> p = rand ( r ); julia> r PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x9b1fc763ae0ad702, 0x0000000000000283) julia> advance! ( r , - 3 ) PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x45389f8b27528b29, 0x0000000000000283) julia> @Test . test A == rand ( r , UInt64 , 2 ) Test Passed julia> @Test . test p == rand ( r ) Test Passed source <a id='RandomNumbers.PCG.bounded_rand-Union{Tuple{OutputType}, Tuple{MethodType}, Tuple{StateType}, Tuple{RandomNumbers.PCG.AbstractPCG{StateType, MethodType, OutputType}, OutputType}} where {StateType<:Union{UInt128, UInt16, UInt32, UInt64, UInt8}, MethodType<:Union{Val{:XSH_RS}, Val{:XSH_RR}, Val{:RXS_M_XS}, Val{:XSL_RR}, Val{:XSL_RR_RR}}, OutputType<:Union{UInt128, UInt16, UInt32, UInt64, UInt8}}' href='#RandomNumbers.PCG.bounded_rand-Union{Tuple{OutputType}, Tuple{MethodType}, Tuple{StateType}, Tuple{RandomNumbers.PCG.AbstractPCG{StateType, MethodType, OutputType}, OutputType}} where {StateType<:Union{UInt128, UInt16, UInt32, UInt64, UInt8}, MethodType<:Union{Val{:XSH_RS}, Val{:XSH_RR}, Val{:RXS_M_XS}, Val{:XSL_RR}, Val{:XSL_RR_RR}}, OutputType<:Union{UInt128, UInt16, UInt32, UInt64, UInt8}}'># RandomNumbers.PCG.bounded_rand \u2014 Method . bounded_rand ( r , bound ) Producing a random number less than a given bound in the output type. source","title":"Public"},{"location":"lib/pcg/#internal","text":"# RandomNumbers.PCG.AbstractPCG \u2014 Type . AbstractPCG { StateType <: PCGUInt , MethodType <: PCGMethod , OutputType <: PCGUInt } <: AbstractRNG { OutputType } The base abstract type for PCGs. source # RandomNumbers.PCG.default_increment \u2014 Method . Return the default increment for a certain type. source # RandomNumbers.PCG.default_multiplier \u2014 Method . Return the default multiplier for a certain type. source # RandomNumbers.PCG.mcg_multiplier \u2014 Method . Return the default MCG multiplier for a certain type. source # RandomNumbers.PCG.mcg_unmultiplier \u2014 Method . Return the default MCG unmultiplier for a certain type. source # RandomNumbers.PCG.pcg_advance! \u2014 Function . Advance a PCG object. source <a id='RandomNumbers.PCG.pcg_advance_lcg-Union{Tuple{T}, NTuple{4, T}} where T<:Union{UInt128, UInt16, UInt32, UInt64, UInt8}' href='#RandomNumbers.PCG.pcg_advance_lcg-Union{Tuple{T}, NTuple{4, T}} where T<:Union{UInt128, UInt16, UInt32, UInt64, UInt8}'># RandomNumbers.PCG.pcg_advance_lcg \u2014 Method . General advance functions. source # RandomNumbers.PCG.pcg_output \u2014 Function . Return the output of a state for a certain PCG type. source # RandomNumbers.PCG.pcg_seed! \u2014 Function . Initialize a PCG object. source # RandomNumbers.PCG.pcg_step! \u2014 Function . Do one iteration step for a PCG object. source","title":"Internal"},{"location":"lib/random-numbers/","text":"RandomNumbers Index RandomNumbers.RandomNumbers RandomNumbers.AbstractRNG RandomNumbers.WrappedRNG RandomNumbers.gen_seed RandomNumbers.output_type RandomNumbers.randfloat RandomNumbers.randfloat RandomNumbers.randfloat RandomNumbers.seed_type Common Functions Base.rand Random.rand! Random.seed! Base.randn Random.randn! Random.randexp Random.randexp! Random.bitrand Random.randstring Random.randsubseq Random.randsubseq! Random.randperm Random.randperm! Random.randcycle Random.randcycle! Random.shuffle Random.shuffle! Public # RandomNumbers.RandomNumbers \u2014 Module . Main module for RandomNumbers.jl \u2013 a random number generator package for Julia Language. This module exports two types and four submodules: AbstractRNG WrappedRNG PCG MersenneTwisters Random123 Xorshifts source # RandomNumbers.AbstractRNG \u2014 Type . AbstractRNG { T } <: Random . AbstractRNG The abstract type of Random Number Generators. T indicates the original output type of a RNG. source # RandomNumbers.WrappedRNG \u2014 Type . WrappedRNG { R , T1 , T2 } <: AbstractRNG { T2 } WrappedRNG ( base_rng , T2 ) WrappedRNG ( R , T2 , args ... ) Wrap a RNG which originally provides output in T1 into a RNG that provides output in T2. Examples julia> r = Xorshifts . Xorshift128Star ( 123 ); julia> RandomNumbers . output_type ( r ) UInt64 julia> r1 = WrappedRNG ( r , UInt32 ); julia> RandomNumbers . output_type ( r1 ) UInt32 julia> r2 = WrappedRNG ( Xorshifts . Xorshift128Star , UInt32 , 123 ); julia> RandomNumbers . output_type ( r2 ) UInt32 julia> @Test . test rand ( r1 , UInt32 , 3 ) == rand ( r2 , UInt32 , 3 ) Test Passed source # RandomNumbers.output_type \u2014 Method . Get the original output type of a RNG. source # RandomNumbers.randfloat \u2014 Method . Random number generator for Float16 in [0,1) that samples from all 15360 float16s in that range. source # RandomNumbers.randfloat \u2014 Method . Random number generator for Float32 in [0,1) that samples from 42*2^23 float32s in [0,1) compared to 2^23 for rand(Float32). source # RandomNumbers.randfloat \u2014 Method . Random number generator for Float64 in [0,1) that samples from 64*2^52 floats compared to 2^52 for rand(Float64). source # RandomNumbers.seed_type \u2014 Method . Get the default seed type of a RNG. source Internal <a id='RandomNumbers.gen_seed-Union{Tuple{Type{T}}, Tuple{T}} where T<:Number' href='#RandomNumbers.gen_seed-Union{Tuple{Type{T}}, Tuple{T}} where T<:Number'># RandomNumbers.gen_seed \u2014 Method . gen_seed ( T [, n ]) Generate a tuple of n truly random numbers in type T . If n is missing, return only one number. The \"truly\" random numbers are provided by the random device of system. See Random.RandomDevice . Examples julia > RandomNumbers . gen_seed ( UInt64 , 2 ) # The output should probably be different on different computers. ( 0x26aa3fe5e306f725 , 0x7b9dc3c227d8acc9 ) julia > RandomNumbers . gen_seed ( UInt32 ) 0x9ba60fdc source","title":"RandomNumbers"},{"location":"lib/random-numbers/#randomnumbers","text":"","title":"RandomNumbers"},{"location":"lib/random-numbers/#index","text":"RandomNumbers.RandomNumbers RandomNumbers.AbstractRNG RandomNumbers.WrappedRNG RandomNumbers.gen_seed RandomNumbers.output_type RandomNumbers.randfloat RandomNumbers.randfloat RandomNumbers.randfloat RandomNumbers.seed_type","title":"Index"},{"location":"lib/random-numbers/#common-functions","text":"Base.rand Random.rand! Random.seed! Base.randn Random.randn! Random.randexp Random.randexp! Random.bitrand Random.randstring Random.randsubseq Random.randsubseq! Random.randperm Random.randperm! Random.randcycle Random.randcycle! Random.shuffle Random.shuffle!","title":"Common Functions"},{"location":"lib/random-numbers/#public","text":"# RandomNumbers.RandomNumbers \u2014 Module . Main module for RandomNumbers.jl \u2013 a random number generator package for Julia Language. This module exports two types and four submodules: AbstractRNG WrappedRNG PCG MersenneTwisters Random123 Xorshifts source # RandomNumbers.AbstractRNG \u2014 Type . AbstractRNG { T } <: Random . AbstractRNG The abstract type of Random Number Generators. T indicates the original output type of a RNG. source # RandomNumbers.WrappedRNG \u2014 Type . WrappedRNG { R , T1 , T2 } <: AbstractRNG { T2 } WrappedRNG ( base_rng , T2 ) WrappedRNG ( R , T2 , args ... ) Wrap a RNG which originally provides output in T1 into a RNG that provides output in T2. Examples julia> r = Xorshifts . Xorshift128Star ( 123 ); julia> RandomNumbers . output_type ( r ) UInt64 julia> r1 = WrappedRNG ( r , UInt32 ); julia> RandomNumbers . output_type ( r1 ) UInt32 julia> r2 = WrappedRNG ( Xorshifts . Xorshift128Star , UInt32 , 123 ); julia> RandomNumbers . output_type ( r2 ) UInt32 julia> @Test . test rand ( r1 , UInt32 , 3 ) == rand ( r2 , UInt32 , 3 ) Test Passed source # RandomNumbers.output_type \u2014 Method . Get the original output type of a RNG. source # RandomNumbers.randfloat \u2014 Method . Random number generator for Float16 in [0,1) that samples from all 15360 float16s in that range. source # RandomNumbers.randfloat \u2014 Method . Random number generator for Float32 in [0,1) that samples from 42*2^23 float32s in [0,1) compared to 2^23 for rand(Float32). source # RandomNumbers.randfloat \u2014 Method . Random number generator for Float64 in [0,1) that samples from 64*2^52 floats compared to 2^52 for rand(Float64). source # RandomNumbers.seed_type \u2014 Method . Get the default seed type of a RNG. source","title":"Public"},{"location":"lib/random-numbers/#internal","text":"<a id='RandomNumbers.gen_seed-Union{Tuple{Type{T}}, Tuple{T}} where T<:Number' href='#RandomNumbers.gen_seed-Union{Tuple{Type{T}}, Tuple{T}} where T<:Number'># RandomNumbers.gen_seed \u2014 Method . gen_seed ( T [, n ]) Generate a tuple of n truly random numbers in type T . If n is missing, return only one number. The \"truly\" random numbers are provided by the random device of system. See Random.RandomDevice . Examples julia > RandomNumbers . gen_seed ( UInt64 , 2 ) # The output should probably be different on different computers. ( 0x26aa3fe5e306f725 , 0x7b9dc3c227d8acc9 ) julia > RandomNumbers . gen_seed ( UInt32 ) 0x9ba60fdc source","title":"Internal"},{"location":"lib/random123/","text":"Random123 Index Random123.Random123 Random123.R123_USE_AESNI Random123.AESNI1x Random123.AESNI4x Random123.AESNIKey Random123.ARS1x Random123.ARS4x Random123.AbstractAESNI1x Random123.AbstractAESNI4x Random123.AbstractR123 Random123.Philox2x Random123.Philox4x Random123.R123Generator1x Random123.R123Generator2x Random123.R123Generator4x Random123.Threefry2x Random123.Threefry4x Random123._aes_128_assist Random123.random123_r Random123.set_counter! Public # Random123.Random123 \u2014 Module . The module for Random123 Family . Provide 8 RNG types: Threefry2x Threefry4x Philox2x Philox4x AESNI1x AESNI4x ARS1x ARS4x source # Random123.R123_USE_AESNI \u2014 Constant . True when AES-NI has been enabled. source # Random123.AESNI1x \u2014 Type . AESNI1x <: AbstractAESNI1x AESNI1x ([ seed ]) AESNI1x is one kind of AESNI Counter-Based RNGs. It generates one UInt128 number at a time. seed is an Integer which will be automatically converted to UInt128 . Only available when R123_USE_AESNI . source # Random123.AESNI4x \u2014 Type . AESNI4x <: AbstractAESNI4x AESNI4x ([ seed ]) AESNI4x is one kind of AESNI Counter-Based RNGs. It generates four UInt32 numbers at a time. seed is a Tuple of four Integer s which will all be automatically converted to UInt32 . Only available when R123_USE_AESNI . source # Random123.ARS1x \u2014 Type . ARS1x { R } <: AbstractAESNI1x ARS1x ([ seed , R = 7 ]) ARS1x is one kind of ARS Counter-Based RNGs. It generates one UInt128 number at a time. seed is an Integer which will be automatically converted to UInt128 . R denotes to the Rounds which should be at least 1 and no more than 10. With 7 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance. Only available when R123_USE_AESNI . source # Random123.ARS4x \u2014 Type . ARS4x { R } <: AbstractAESNI4x ARS4x ([ seed , R = 7 ]) ARS4x is one kind of ARS Counter-Based RNGs. It generates four UInt32 numbers at a time. seed is a Tuple of four Integer s which will all be automatically converted to UInt32 . R denotes to the Rounds which must be at least 1 and no more than 10. With 7 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance. Only available when R123_USE_AESNI . source # Random123.Philox2x \u2014 Type . Philox2x { T , R } <: R123Generator2x { T } Philox2x ([ seed , R ]) Philox2x ( T [, seed , R ]) Philox2x is one kind of Philox Counter-Based RNGs. It generates two numbers at a time. T is UInt32 or UInt64 (default). seed is an Integer which will be automatically converted to T . R denotes to the Rounds which must be at least 1 and no more than 16. With 10 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance. source # Random123.Philox4x \u2014 Type . Philox4x { T , R } <: R123Generator4x { T } Philox4x ([ seed , R ]) Philox4x ( T [, seed , R ]) Philox4x is one kind of Philox Counter-Based RNGs. It generates four numbers at a time. T is UInt32 or UInt64 (default). seed is a Tuple of two Integer s which will both be automatically converted to T . R denotes to the Rounds which must be at least 1 and no more than 16. With 10 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance. source # Random123.Threefry2x \u2014 Type . Threefry2x { T , R } <: R123Generator2x { T } Threefry2x ([ seed , R ]) Threefry2x ( T [, seed , R ]) Threefry2x is one kind of Threefry Counter-Based RNGs. It generates two numbers at a time. T is UInt32 or UInt64 (default). seed is a Tuple of two Integer s which will both be automatically converted to T . R denotes to the Rounds which must be at least 1 and no more than 32. With 20 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance. source # Random123.Threefry4x \u2014 Type . Threefry4x { T , R } <: R123Generator4x { T } Threefry4x ([ seed , R ]) Threefry4x ( T [, seed , R ]) Threefry2x is one kind of Threefry Counter-Based RNGs. It generates four numbers at a time. T is UInt32 or UInt64 (default). seed is a Tuple of four Integer s which will all be automatically converted to T . R denotes to the Rounds which must be at least 1 and no more than 32. With 20 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance. source <a id='Random123.set_counter!-Union{Tuple{T}, Tuple{Random123.R123Generator1x{T}, Integer}} where T<:UInt128' href='#Random123.set_counter!-Union{Tuple{T}, Tuple{Random123.R123Generator1x{T}, Integer}} where T<:UInt128'># Random123.set_counter! \u2014 Method . Set the counter of a Random123 RNG. source Internal # Random123.AESNIKey \u2014 Type . The key for AESNI. source # Random123.AbstractAESNI1x \u2014 Type . Abstract RNG that generates one number at a time and is based on AESNI. source # Random123.AbstractAESNI4x \u2014 Type . Abstract RNG that generates four numbers at a time and is based on AESNI. source # Random123.AbstractR123 \u2014 Type . The base abstract type for RNGs in Random123 Family . source # Random123.R123Generator1x \u2014 Type . RNG that generates one number at a time. source # Random123.R123Generator2x \u2014 Type . RNG that generates two numbers at a time. source # Random123.R123Generator4x \u2014 Type . RNG that generates four numbers at a time. source # Random123._aes_128_assist \u2014 Method . Assistant function for AES128. Compiled from the C++ source code: R123_STATIC_INLINE __m128i AES_128_ASSIST ( __m128i temp1 , __m128i temp2 ) { __m128i temp3 ; temp2 = _mm_shuffle_epi32 ( temp2 , 0xff ); temp3 = _mm_slli_si128 ( temp1 , 0x4 ); temp1 = _mm_xor_si128 ( temp1 , temp3 ); temp3 = _mm_slli_si128 ( temp3 , 0x4 ); temp1 = _mm_xor_si128 ( temp1 , temp3 ); temp3 = _mm_slli_si128 ( temp3 , 0x4 ); temp1 = _mm_xor_si128 ( temp1 , temp3 ); temp1 = _mm_xor_si128 ( temp1 , temp2 ); return temp1 ; } source # Random123.random123_r \u2014 Function . Do one iteration and return the result tuple of a Random123 RNG object. source","title":"Random123"},{"location":"lib/random123/#random123","text":"","title":"Random123"},{"location":"lib/random123/#index","text":"Random123.Random123 Random123.R123_USE_AESNI Random123.AESNI1x Random123.AESNI4x Random123.AESNIKey Random123.ARS1x Random123.ARS4x Random123.AbstractAESNI1x Random123.AbstractAESNI4x Random123.AbstractR123 Random123.Philox2x Random123.Philox4x Random123.R123Generator1x Random123.R123Generator2x Random123.R123Generator4x Random123.Threefry2x Random123.Threefry4x Random123._aes_128_assist Random123.random123_r Random123.set_counter!","title":"Index"},{"location":"lib/random123/#public","text":"# Random123.Random123 \u2014 Module . The module for Random123 Family . Provide 8 RNG types: Threefry2x Threefry4x Philox2x Philox4x AESNI1x AESNI4x ARS1x ARS4x source # Random123.R123_USE_AESNI \u2014 Constant . True when AES-NI has been enabled. source # Random123.AESNI1x \u2014 Type . AESNI1x <: AbstractAESNI1x AESNI1x ([ seed ]) AESNI1x is one kind of AESNI Counter-Based RNGs. It generates one UInt128 number at a time. seed is an Integer which will be automatically converted to UInt128 . Only available when R123_USE_AESNI . source # Random123.AESNI4x \u2014 Type . AESNI4x <: AbstractAESNI4x AESNI4x ([ seed ]) AESNI4x is one kind of AESNI Counter-Based RNGs. It generates four UInt32 numbers at a time. seed is a Tuple of four Integer s which will all be automatically converted to UInt32 . Only available when R123_USE_AESNI . source # Random123.ARS1x \u2014 Type . ARS1x { R } <: AbstractAESNI1x ARS1x ([ seed , R = 7 ]) ARS1x is one kind of ARS Counter-Based RNGs. It generates one UInt128 number at a time. seed is an Integer which will be automatically converted to UInt128 . R denotes to the Rounds which should be at least 1 and no more than 10. With 7 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance. Only available when R123_USE_AESNI . source # Random123.ARS4x \u2014 Type . ARS4x { R } <: AbstractAESNI4x ARS4x ([ seed , R = 7 ]) ARS4x is one kind of ARS Counter-Based RNGs. It generates four UInt32 numbers at a time. seed is a Tuple of four Integer s which will all be automatically converted to UInt32 . R denotes to the Rounds which must be at least 1 and no more than 10. With 7 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance. Only available when R123_USE_AESNI . source # Random123.Philox2x \u2014 Type . Philox2x { T , R } <: R123Generator2x { T } Philox2x ([ seed , R ]) Philox2x ( T [, seed , R ]) Philox2x is one kind of Philox Counter-Based RNGs. It generates two numbers at a time. T is UInt32 or UInt64 (default). seed is an Integer which will be automatically converted to T . R denotes to the Rounds which must be at least 1 and no more than 16. With 10 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance. source # Random123.Philox4x \u2014 Type . Philox4x { T , R } <: R123Generator4x { T } Philox4x ([ seed , R ]) Philox4x ( T [, seed , R ]) Philox4x is one kind of Philox Counter-Based RNGs. It generates four numbers at a time. T is UInt32 or UInt64 (default). seed is a Tuple of two Integer s which will both be automatically converted to T . R denotes to the Rounds which must be at least 1 and no more than 16. With 10 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance. source # Random123.Threefry2x \u2014 Type . Threefry2x { T , R } <: R123Generator2x { T } Threefry2x ([ seed , R ]) Threefry2x ( T [, seed , R ]) Threefry2x is one kind of Threefry Counter-Based RNGs. It generates two numbers at a time. T is UInt32 or UInt64 (default). seed is a Tuple of two Integer s which will both be automatically converted to T . R denotes to the Rounds which must be at least 1 and no more than 32. With 20 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance. source # Random123.Threefry4x \u2014 Type . Threefry4x { T , R } <: R123Generator4x { T } Threefry4x ([ seed , R ]) Threefry4x ( T [, seed , R ]) Threefry2x is one kind of Threefry Counter-Based RNGs. It generates four numbers at a time. T is UInt32 or UInt64 (default). seed is a Tuple of four Integer s which will all be automatically converted to T . R denotes to the Rounds which must be at least 1 and no more than 32. With 20 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance. source <a id='Random123.set_counter!-Union{Tuple{T}, Tuple{Random123.R123Generator1x{T}, Integer}} where T<:UInt128' href='#Random123.set_counter!-Union{Tuple{T}, Tuple{Random123.R123Generator1x{T}, Integer}} where T<:UInt128'># Random123.set_counter! \u2014 Method . Set the counter of a Random123 RNG. source","title":"Public"},{"location":"lib/random123/#internal","text":"# Random123.AESNIKey \u2014 Type . The key for AESNI. source # Random123.AbstractAESNI1x \u2014 Type . Abstract RNG that generates one number at a time and is based on AESNI. source # Random123.AbstractAESNI4x \u2014 Type . Abstract RNG that generates four numbers at a time and is based on AESNI. source # Random123.AbstractR123 \u2014 Type . The base abstract type for RNGs in Random123 Family . source # Random123.R123Generator1x \u2014 Type . RNG that generates one number at a time. source # Random123.R123Generator2x \u2014 Type . RNG that generates two numbers at a time. source # Random123.R123Generator4x \u2014 Type . RNG that generates four numbers at a time. source # Random123._aes_128_assist \u2014 Method . Assistant function for AES128. Compiled from the C++ source code: R123_STATIC_INLINE __m128i AES_128_ASSIST ( __m128i temp1 , __m128i temp2 ) { __m128i temp3 ; temp2 = _mm_shuffle_epi32 ( temp2 , 0xff ); temp3 = _mm_slli_si128 ( temp1 , 0x4 ); temp1 = _mm_xor_si128 ( temp1 , temp3 ); temp3 = _mm_slli_si128 ( temp3 , 0x4 ); temp1 = _mm_xor_si128 ( temp1 , temp3 ); temp3 = _mm_slli_si128 ( temp3 , 0x4 ); temp1 = _mm_xor_si128 ( temp1 , temp3 ); temp1 = _mm_xor_si128 ( temp1 , temp2 ); return temp1 ; } source # Random123.random123_r \u2014 Function . Do one iteration and return the result tuple of a Random123 RNG object. source","title":"Internal"},{"location":"lib/xorshifts/","text":"Xorshifts Index RandomNumbers.Xorshifts RandomNumbers.Xorshifts.AbstractXoroshiro128 RandomNumbers.Xorshifts.AbstractXoroshiro64 RandomNumbers.Xorshifts.AbstractXorshift1024 RandomNumbers.Xorshifts.AbstractXorshift128 RandomNumbers.Xorshifts.AbstractXorshift64 RandomNumbers.Xorshifts.AbstractXoshiro128 RandomNumbers.Xorshifts.AbstractXoshiro256 RandomNumbers.Xorshifts.SplitMix64 RandomNumbers.Xorshifts.Xoroshiro128 RandomNumbers.Xorshifts.Xoroshiro128Plus RandomNumbers.Xorshifts.Xoroshiro128Star RandomNumbers.Xorshifts.Xoroshiro128StarStar RandomNumbers.Xorshifts.Xoroshiro64Star RandomNumbers.Xorshifts.Xoroshiro64StarStar RandomNumbers.Xorshifts.Xorshift1024 RandomNumbers.Xorshifts.Xorshift1024Plus RandomNumbers.Xorshifts.Xorshift1024Star RandomNumbers.Xorshifts.Xorshift128 RandomNumbers.Xorshifts.Xorshift128Plus RandomNumbers.Xorshifts.Xorshift128Star RandomNumbers.Xorshifts.Xorshift64 RandomNumbers.Xorshifts.Xorshift64Star RandomNumbers.Xorshifts.Xoshiro128Plus RandomNumbers.Xorshifts.Xoshiro128StarStar RandomNumbers.Xorshifts.Xoshiro256Plus RandomNumbers.Xorshifts.Xoshiro256StarStar RandomNumbers.Xorshifts.xorshift_next Public # RandomNumbers.Xorshifts \u2014 Module . The module for Xorshift Family . Provide 8 RNG types (others are to be deprecated): Xoroshiro64Star Xoroshiro64StarStar Xoroshiro128Plus Xoroshiro128StarStar Xoshiro128Plus Xoshiro128StarStar Xoshiro256Plus Xoshiro256StarStar source # RandomNumbers.Xorshifts.Xoroshiro128 \u2014 Type . Xoroshiro128 <: AbstractXoroshiro128 Xoroshiro128 ([ seed ]) Xoroshiro128 RNG. The seed can be a Tuple of two UInt64 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xoroshiro128Plus \u2014 Type . Xoroshiro128Plus <: AbstractXoroshiro128 Xoroshiro128Plus ([ seed ]) Xoroshiro128Plus RNG. The seed can be a Tuple of two UInt64 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xoroshiro128Star \u2014 Type . Xoroshiro128Star <: AbstractXoroshiro128 Xoroshiro128Star ([ seed ]) Xoroshiro128Star RNG. The seed can be a Tuple of two UInt64 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xoroshiro128StarStar \u2014 Type . Xoroshiro128StarStar <: AbstractXoroshiro128 Xoroshiro128StarStar ([ seed ]) Xoroshiro128StarStar RNG. The seed can be a Tuple of two UInt64 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xoroshiro64Star \u2014 Type . Xoroshiro64Star <: AbstractXoroshiro64 Xoroshiro64Star ([ seed ]) Xoroshiro64Star RNG. The seed can be a Tuple of two UInt32 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xoroshiro64StarStar \u2014 Type . Xoroshiro64StarStar <: AbstractXoroshiro64 Xoroshiro64StarStar ([ seed ]) Xoroshiro64StarStar RNG. The seed can be a Tuple of two UInt32 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xorshift1024 \u2014 Type . Xorshift1024 <: AbstractXorshift1024 Xorshift1024 ([ seed ... ]) Xorshift1024 RNG. The seed can be a Tuple of 16 UInt64 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xorshift1024Plus \u2014 Type . Xorshift1024Plus <: AbstractXorshift1024 Xorshift1024Plus ([ seed ... ]) Xorshift1024Plus RNG. The seed can be a Tuple of 16 UInt64 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xorshift1024Star \u2014 Type . Xorshift1024Star <: AbstractXorshift1024 Xorshift1024Star ([ seed ... ]) Xorshift1024Star RNG. The seed can be a Tuple of 16 UInt64 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xorshift128 \u2014 Type . Xorshift128 <: AbstractXorshift128 Xorshift128 ([ seed ]) Xorshift128 RNG. The seed can be a Tuple of two UInt64 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xorshift128Plus \u2014 Type . Xorshift128Plus <: AbstractXorshift128 Xorshift128Plus ([ seed ]) Xorshift128Plus RNG. The seed can be a Tuple of two UInt64 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xorshift128Star \u2014 Type . Xorshift128Star <: AbstractXorshift128 Xorshift128Star ([ seed ]) Xorshift128Star RNG. The seed can be a Tuple of two UInt64 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xorshift64 \u2014 Type . Xorshift64 <: AbstractXorshift64 Xorshift64 ([ seed ]) Xorshift64 RNG. The seed can be an UInt64 , or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xorshift64Star \u2014 Type . Xorshift64Star <: AbstractXorshift64 Xorshift64Star ([ seed ]) Xorshift64Star RNG. The seed can be an UInt64 , or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xoshiro128Plus \u2014 Type . Xoshiro128Plus <: AbstractXoshiro128 Xoshiro128Plus ([ seed ]) Xoshiro128Plus RNG. The seed can be a Tuple of four UInt32 s, a Tuple of two, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xoshiro128StarStar \u2014 Type . Xoshiro128StarStar <: AbstractXoshiro128 Xoshiro128StarStar ([ seed ]) Xoshiro128StarStar RNG. The seed can be a Tuple of four UInt32 s, a Tuple of two, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xoshiro256Plus \u2014 Type . Xoshiro256Plus <: AbstractXoshiro256 Xoshiro256Plus ([ seed ]) Xoshiro256Plus RNG. The seed can be a Tuple of four UInt64 s, or an Integer which will be automatically convert to an UInt64 number (and then is initialized with SplitMix64). Zero seeds are not acceptable. source # RandomNumbers.Xorshifts.Xoshiro256StarStar \u2014 Type . Xoshiro256StarStar <: AbstractXoshiro256 Xoshiro256StarStar ([ seed ]) Xoshiro256StarStar RNG. The seed can be a Tuple of four UInt64 s, or an Integer which will be automatically convert to an UInt64 number (and then is initialized with SplitMix64). Zero seeds are not acceptable. source Internal # RandomNumbers.Xorshifts.AbstractXoroshiro128 \u2014 Type . AbstractXoroshiro128 <: AbstractRNG { UInt64 } The base abstract type for Xoroshiro128 , Xoroshiro128Star , Xoroshiro128Plus and Xoroshiro128StarStar . source # RandomNumbers.Xorshifts.AbstractXoroshiro64 \u2014 Type . AbstractXoroshiro64 <: AbstractRNG { UInt32 } The base abstract type for Xoroshiro64Star and Xoroshiro64StarStar . source # RandomNumbers.Xorshifts.AbstractXorshift1024 \u2014 Type . AbstractXorshift1024 <: AbstractRNG { UInt64 } The base abstract type for Xorshift1024 , Xorshift1024Star and Xorshift1024Plus . source # RandomNumbers.Xorshifts.AbstractXorshift128 \u2014 Type . AbstractXorshift128 <: AbstractRNG { UInt64 } The base abstract type for Xorshift128 , Xorshift128Star and Xorshift128Plus . source # RandomNumbers.Xorshifts.AbstractXorshift64 \u2014 Type . AbstractXorshift64 <: AbstractRNG { UInt64 } The base abstract type for Xorshift64 and Xorshift64Star . source # RandomNumbers.Xorshifts.AbstractXoshiro128 \u2014 Type . AbstractXoshiro128 <: AbstractRNG { UInt32 } The base abstract type for Xoshiro128Plus and Xoshiro128StarStar . source # RandomNumbers.Xorshifts.AbstractXoshiro256 \u2014 Type . AbstractXoshiro256 <: AbstractRNG { UInt64 } The base abstract type for Xoshiro256Plus and Xoshiro256StarStar . source # RandomNumbers.Xorshifts.SplitMix64 \u2014 Type . SplitMix64 <: AbstractRNG { UInt64 } SplitMix64 ([ seed ]) Used for initializing a random seed. source # RandomNumbers.Xorshifts.xorshift_next \u2014 Function . Do one iteration and get the current value of a Xorshift RNG object. source","title":"Xorshifts"},{"location":"lib/xorshifts/#xorshifts","text":"","title":"Xorshifts"},{"location":"lib/xorshifts/#index","text":"RandomNumbers.Xorshifts RandomNumbers.Xorshifts.AbstractXoroshiro128 RandomNumbers.Xorshifts.AbstractXoroshiro64 RandomNumbers.Xorshifts.AbstractXorshift1024 RandomNumbers.Xorshifts.AbstractXorshift128 RandomNumbers.Xorshifts.AbstractXorshift64 RandomNumbers.Xorshifts.AbstractXoshiro128 RandomNumbers.Xorshifts.AbstractXoshiro256 RandomNumbers.Xorshifts.SplitMix64 RandomNumbers.Xorshifts.Xoroshiro128 RandomNumbers.Xorshifts.Xoroshiro128Plus RandomNumbers.Xorshifts.Xoroshiro128Star RandomNumbers.Xorshifts.Xoroshiro128StarStar RandomNumbers.Xorshifts.Xoroshiro64Star RandomNumbers.Xorshifts.Xoroshiro64StarStar RandomNumbers.Xorshifts.Xorshift1024 RandomNumbers.Xorshifts.Xorshift1024Plus RandomNumbers.Xorshifts.Xorshift1024Star RandomNumbers.Xorshifts.Xorshift128 RandomNumbers.Xorshifts.Xorshift128Plus RandomNumbers.Xorshifts.Xorshift128Star RandomNumbers.Xorshifts.Xorshift64 RandomNumbers.Xorshifts.Xorshift64Star RandomNumbers.Xorshifts.Xoshiro128Plus RandomNumbers.Xorshifts.Xoshiro128StarStar RandomNumbers.Xorshifts.Xoshiro256Plus RandomNumbers.Xorshifts.Xoshiro256StarStar RandomNumbers.Xorshifts.xorshift_next","title":"Index"},{"location":"lib/xorshifts/#public","text":"# RandomNumbers.Xorshifts \u2014 Module . The module for Xorshift Family . Provide 8 RNG types (others are to be deprecated): Xoroshiro64Star Xoroshiro64StarStar Xoroshiro128Plus Xoroshiro128StarStar Xoshiro128Plus Xoshiro128StarStar Xoshiro256Plus Xoshiro256StarStar source # RandomNumbers.Xorshifts.Xoroshiro128 \u2014 Type . Xoroshiro128 <: AbstractXoroshiro128 Xoroshiro128 ([ seed ]) Xoroshiro128 RNG. The seed can be a Tuple of two UInt64 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xoroshiro128Plus \u2014 Type . Xoroshiro128Plus <: AbstractXoroshiro128 Xoroshiro128Plus ([ seed ]) Xoroshiro128Plus RNG. The seed can be a Tuple of two UInt64 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xoroshiro128Star \u2014 Type . Xoroshiro128Star <: AbstractXoroshiro128 Xoroshiro128Star ([ seed ]) Xoroshiro128Star RNG. The seed can be a Tuple of two UInt64 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xoroshiro128StarStar \u2014 Type . Xoroshiro128StarStar <: AbstractXoroshiro128 Xoroshiro128StarStar ([ seed ]) Xoroshiro128StarStar RNG. The seed can be a Tuple of two UInt64 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xoroshiro64Star \u2014 Type . Xoroshiro64Star <: AbstractXoroshiro64 Xoroshiro64Star ([ seed ]) Xoroshiro64Star RNG. The seed can be a Tuple of two UInt32 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xoroshiro64StarStar \u2014 Type . Xoroshiro64StarStar <: AbstractXoroshiro64 Xoroshiro64StarStar ([ seed ]) Xoroshiro64StarStar RNG. The seed can be a Tuple of two UInt32 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xorshift1024 \u2014 Type . Xorshift1024 <: AbstractXorshift1024 Xorshift1024 ([ seed ... ]) Xorshift1024 RNG. The seed can be a Tuple of 16 UInt64 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xorshift1024Plus \u2014 Type . Xorshift1024Plus <: AbstractXorshift1024 Xorshift1024Plus ([ seed ... ]) Xorshift1024Plus RNG. The seed can be a Tuple of 16 UInt64 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xorshift1024Star \u2014 Type . Xorshift1024Star <: AbstractXorshift1024 Xorshift1024Star ([ seed ... ]) Xorshift1024Star RNG. The seed can be a Tuple of 16 UInt64 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xorshift128 \u2014 Type . Xorshift128 <: AbstractXorshift128 Xorshift128 ([ seed ]) Xorshift128 RNG. The seed can be a Tuple of two UInt64 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xorshift128Plus \u2014 Type . Xorshift128Plus <: AbstractXorshift128 Xorshift128Plus ([ seed ]) Xorshift128Plus RNG. The seed can be a Tuple of two UInt64 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xorshift128Star \u2014 Type . Xorshift128Star <: AbstractXorshift128 Xorshift128Star ([ seed ]) Xorshift128Star RNG. The seed can be a Tuple of two UInt64 s, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xorshift64 \u2014 Type . Xorshift64 <: AbstractXorshift64 Xorshift64 ([ seed ]) Xorshift64 RNG. The seed can be an UInt64 , or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xorshift64Star \u2014 Type . Xorshift64Star <: AbstractXorshift64 Xorshift64Star ([ seed ]) Xorshift64Star RNG. The seed can be an UInt64 , or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xoshiro128Plus \u2014 Type . Xoshiro128Plus <: AbstractXoshiro128 Xoshiro128Plus ([ seed ]) Xoshiro128Plus RNG. The seed can be a Tuple of four UInt32 s, a Tuple of two, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xoshiro128StarStar \u2014 Type . Xoshiro128StarStar <: AbstractXoshiro128 Xoshiro128StarStar ([ seed ]) Xoshiro128StarStar RNG. The seed can be a Tuple of four UInt32 s, a Tuple of two, or an Integer which will be initialized with SplitMix64 . source # RandomNumbers.Xorshifts.Xoshiro256Plus \u2014 Type . Xoshiro256Plus <: AbstractXoshiro256 Xoshiro256Plus ([ seed ]) Xoshiro256Plus RNG. The seed can be a Tuple of four UInt64 s, or an Integer which will be automatically convert to an UInt64 number (and then is initialized with SplitMix64). Zero seeds are not acceptable. source # RandomNumbers.Xorshifts.Xoshiro256StarStar \u2014 Type . Xoshiro256StarStar <: AbstractXoshiro256 Xoshiro256StarStar ([ seed ]) Xoshiro256StarStar RNG. The seed can be a Tuple of four UInt64 s, or an Integer which will be automatically convert to an UInt64 number (and then is initialized with SplitMix64). Zero seeds are not acceptable. source","title":"Public"},{"location":"lib/xorshifts/#internal","text":"# RandomNumbers.Xorshifts.AbstractXoroshiro128 \u2014 Type . AbstractXoroshiro128 <: AbstractRNG { UInt64 } The base abstract type for Xoroshiro128 , Xoroshiro128Star , Xoroshiro128Plus and Xoroshiro128StarStar . source # RandomNumbers.Xorshifts.AbstractXoroshiro64 \u2014 Type . AbstractXoroshiro64 <: AbstractRNG { UInt32 } The base abstract type for Xoroshiro64Star and Xoroshiro64StarStar . source # RandomNumbers.Xorshifts.AbstractXorshift1024 \u2014 Type . AbstractXorshift1024 <: AbstractRNG { UInt64 } The base abstract type for Xorshift1024 , Xorshift1024Star and Xorshift1024Plus . source # RandomNumbers.Xorshifts.AbstractXorshift128 \u2014 Type . AbstractXorshift128 <: AbstractRNG { UInt64 } The base abstract type for Xorshift128 , Xorshift128Star and Xorshift128Plus . source # RandomNumbers.Xorshifts.AbstractXorshift64 \u2014 Type . AbstractXorshift64 <: AbstractRNG { UInt64 } The base abstract type for Xorshift64 and Xorshift64Star . source # RandomNumbers.Xorshifts.AbstractXoshiro128 \u2014 Type . AbstractXoshiro128 <: AbstractRNG { UInt32 } The base abstract type for Xoshiro128Plus and Xoshiro128StarStar . source # RandomNumbers.Xorshifts.AbstractXoshiro256 \u2014 Type . AbstractXoshiro256 <: AbstractRNG { UInt64 } The base abstract type for Xoshiro256Plus and Xoshiro256StarStar . source # RandomNumbers.Xorshifts.SplitMix64 \u2014 Type . SplitMix64 <: AbstractRNG { UInt64 } SplitMix64 ([ seed ]) Used for initializing a random seed. source # RandomNumbers.Xorshifts.xorshift_next \u2014 Function . Do one iteration and get the current value of a Xorshift RNG object. source","title":"Internal"},{"location":"man/basics/","text":"Basics This page describes basic concepts and fundamental knowledge of RandomNumbers.jl . Note Unless otherwise specified, all the random number generators in this package are pseudorandom number generators (or deterministic random bit generator), which means they only provide numbers whose properties approximate the properties of truly random numbers. Always, especially in secure-sensitive cases, keep in mind that they do not gaurantee a totally random performance. Installation This package is registered. The stable version of this package requires Julia 0.7+ . You can install it by: ( v1 .0 ) pkg > add RandomNumbers It is recommended to run the test suites before using the package: ( v1 .0 ) pkg > test RandomNumbers Interface First of all, to use a RNG from this package, you can import RandomNumbers.jl and use RNG by declare its submodule's name, or directly import the submodule. Then you can create a random number generator of certain type. For example: julia > using RandomNumbers julia > r = Xorshifts . Xorshift1024Plus () or julia > using RandomNumbers . Xorshifts julia > r = Xorshift1024Plus () The submodules have some API in common and a few differently. All the Random Number Generators (RNGs) are child types of AbstractRNG{T} , which is a child type of Base.Random.AbstractRNG and replaces it. ( Base.Random may be refactored sometime, anyway.) The type parameter T indicates the original output type of a RNG, and it is usually a child type of Unsigned , such as UInt64 , UInt32 , etc. Users can change the output type of a certain RNG type by use a wrapped type: WrappedRNG . Consistent to what Base.Random does, there are generic functions: seed!(::AbstractRNG{T}[, seed]) initializes a RNG by one or a sequence of numbers (called seed ). The output sequences by two RNGs of the same type should be the same if they are initialized by the same seed, which makes them deterministic . The seed type of each RNG type can be different, you can refer to the corresponding manual pages for details. If no seed provided, then it will use RandomNumbers.gen_seed to get a \"truly\" random one. rand(::AbstractRNG{T}[, ::Type{TP}=Float64]) returns a random number in the type TP . TP is usually an Unsigned type, and the return value is expected to be uniformly distributed in {0, 1} at every bit. When TP is Float64 (as default), this function returns a Float64 value that is expected to be uniformly distributed in $[0, 1)$. The discussion about this is in the Conversion to Float section. The other common functions such as rand(::AbstractRNG, ::Dims) and rand!(::AbstractRNG, ::AbstractArray) , and the ones that generate random numbers in a certain distribution such as randn , randexp , randcycle , etc. defined in the standard library Random still work well. See the official docs for details. You can also refer to this section for the common functions. The constructors of all the types of RNG are designed to take the same kind of parameters as seed! . For example: julia> using RandomNumbers . Xorshifts julia> import Random : rand! julia> r1 = Xorshift128Star ( 123 ) # Create a RNG of Xorshift128Star with the seed \"123\" Xorshift128Star(0x000000003a300074, 0x000000003a30004e) julia> r2 = Xorshift128Star (); # Use a random value to be the seed. julia> rand ( r1 ) # Generate a number uniformly distributed in ``[0, 1)``. 0.2552720033868119 julia> A = rand ( r1 , UInt64 , 2 , 3 ) # Generate a 2x3 matrix `A` in `UInt64` type. 2\u00d73 Array{UInt64,2}: 0xbed3dea863c65407 0x607f5f9815f515af 0x807289d8f9847407 0x4ab80d43269335ee 0xf78b56ada11ea641 0xc2306a55acfb4aaa julia> rand! ( r1 , A ) # Refill `A` with random numbers. 2\u00d73 Array{UInt64,2}: 0xf729352e2a72b541 0xe89948b5582a85f0 0x8a95ebd6aa34fcf4 0xc0c5a8df4c1b160f 0x8b5269ed6c790e08 0x930b89985ae0c865 People will get the same results in their own computers of the above lines. For more interfaces and usage examples, please refer to the manual pages of each RNG. Empirical Statistical Testing Empirical statistical testing is very important for random number generation, because the theoretical mathematical analysis is insufficient to verify the performance of a random number generator. The famous and highly evaluated TestU01 library is chosen to test the RNGs in RandomNumbers.jl . TestU01 offers a collection of test suites, and Big Crush is the largest and most stringent test battery for empirical testing (which usually takes several hours to run). Big Crush has revealed a number of flaws of lots of well-used generators, even including the Mersenne Twister (or to be more exact, the dSFMT ) which is currently used in Base.Random as GLOBAL_RAND`. 1 This package chooses RNGTest.jl to use TestU01. The testing results are available on Benchmark page. Conversion to Float Besides the statistical flaws, popular generators often neglect the importance of converting unsigned integers to floating numbers. The most common situation is to convert an UInt to a Float64 which is uniformly distributed in $[0.0, 1.0)$. For example, neither the std::uniform_real_distribution in libstdc++ from gcc, libc++ from llvm, nor the standard library from MSVC has a correct performance, as they all have a non-zero probability for generating the max value which is an open bound and should not be produced. The cause is that a Float64 number in $[0.0, 1.0)$ has only 53 significand bits (52 explicitly stored), which means at least 11 bits of an UInt64 are abandoned when being converted to Float64 . If using the naive approach to multiply an UInt64 by $2^{-64}$, users may get 1.0, and the distribution is not good (although using $2^{-32}$ for an UInt32 is OK). In this package, we make use of the fact that the distribution of the least 52 bits can be the same in an UInt64 and a Float64 (if you are familiar with IEEE 754 this is easy to understand). An UInt64 will firstly be converted to a Float64 that is perfectly uniformly distributed in [1.0, 2.0), and then subtract one. This is a very fast approach, but not completely ideal, as the statistics of the least significant bits are affected. Due to rounding in the subtraction, the least significant bit of rand() is always 0, the second last is only at 25% a 1, the third last bit is at 37.5% chance a 1, the n-th last bit is at p=1/2-2^(-n) chance a 1. In practice, this only affects the last few bits, but holds for rand(Float32) as well as for rand(Float64) . the sampling is not from all floats in [0,1) but only from 2^23 (Float32) or 2^52 (Float64). The subset of floats which is sampled from is every second float in [1/2,1), every 4th in [1/4,1/2), so every 2n-th in [1/2n,1/n). The smallest positive float (but note that 0f0/0.0 is also possible) that is sampled is eps(Float32)=1.1920929f-7 (Float32) or eps(Float64)=2.220446049250313e-16 (Float64). The current default RNG in Base.Random library does the same thing, so it also causes some tricky problems. 2 To address some of these issues RandomNumbers.jl also provides randfloat() for Float16 , Float32 and Float64 , which has full entropy for all significant bits, i.e. 0 and 1 always occur at 50% chance samples from all floats in [2.7105054f-20,1) (Float32) and [2.710505431213761e-20,1) (Float64) and true [0,1) (Float16, including correct chances for subnormals) As the true chance to obtain a 0 in [0,1) for floats is effectively 0, it is practically also 0 for randfloat (except for Float16). is about 20% slower than rand , see #72 randfloat() is not based on the [1,2) minus one -approach but counts the leading zeros of a random UInt to obtain the correct chances for the exponent bits (which are 50% for 01111110 meaning [1/2,1) in float32, 25% for 01111101 meaning [1/4,1/2), etc.). This is combined with random UInt bits for the significand. rand fails bigcrush #6464 \u21a9 Least significant bit of rand() is always zero #16344 \u21a9","title":"Basics"},{"location":"man/basics/#basics","text":"This page describes basic concepts and fundamental knowledge of RandomNumbers.jl . Note Unless otherwise specified, all the random number generators in this package are pseudorandom number generators (or deterministic random bit generator), which means they only provide numbers whose properties approximate the properties of truly random numbers. Always, especially in secure-sensitive cases, keep in mind that they do not gaurantee a totally random performance.","title":"Basics"},{"location":"man/basics/#installation","text":"This package is registered. The stable version of this package requires Julia 0.7+ . You can install it by: ( v1 .0 ) pkg > add RandomNumbers It is recommended to run the test suites before using the package: ( v1 .0 ) pkg > test RandomNumbers","title":"Installation"},{"location":"man/basics/#interface","text":"First of all, to use a RNG from this package, you can import RandomNumbers.jl and use RNG by declare its submodule's name, or directly import the submodule. Then you can create a random number generator of certain type. For example: julia > using RandomNumbers julia > r = Xorshifts . Xorshift1024Plus () or julia > using RandomNumbers . Xorshifts julia > r = Xorshift1024Plus () The submodules have some API in common and a few differently. All the Random Number Generators (RNGs) are child types of AbstractRNG{T} , which is a child type of Base.Random.AbstractRNG and replaces it. ( Base.Random may be refactored sometime, anyway.) The type parameter T indicates the original output type of a RNG, and it is usually a child type of Unsigned , such as UInt64 , UInt32 , etc. Users can change the output type of a certain RNG type by use a wrapped type: WrappedRNG . Consistent to what Base.Random does, there are generic functions: seed!(::AbstractRNG{T}[, seed]) initializes a RNG by one or a sequence of numbers (called seed ). The output sequences by two RNGs of the same type should be the same if they are initialized by the same seed, which makes them deterministic . The seed type of each RNG type can be different, you can refer to the corresponding manual pages for details. If no seed provided, then it will use RandomNumbers.gen_seed to get a \"truly\" random one. rand(::AbstractRNG{T}[, ::Type{TP}=Float64]) returns a random number in the type TP . TP is usually an Unsigned type, and the return value is expected to be uniformly distributed in {0, 1} at every bit. When TP is Float64 (as default), this function returns a Float64 value that is expected to be uniformly distributed in $[0, 1)$. The discussion about this is in the Conversion to Float section. The other common functions such as rand(::AbstractRNG, ::Dims) and rand!(::AbstractRNG, ::AbstractArray) , and the ones that generate random numbers in a certain distribution such as randn , randexp , randcycle , etc. defined in the standard library Random still work well. See the official docs for details. You can also refer to this section for the common functions. The constructors of all the types of RNG are designed to take the same kind of parameters as seed! . For example: julia> using RandomNumbers . Xorshifts julia> import Random : rand! julia> r1 = Xorshift128Star ( 123 ) # Create a RNG of Xorshift128Star with the seed \"123\" Xorshift128Star(0x000000003a300074, 0x000000003a30004e) julia> r2 = Xorshift128Star (); # Use a random value to be the seed. julia> rand ( r1 ) # Generate a number uniformly distributed in ``[0, 1)``. 0.2552720033868119 julia> A = rand ( r1 , UInt64 , 2 , 3 ) # Generate a 2x3 matrix `A` in `UInt64` type. 2\u00d73 Array{UInt64,2}: 0xbed3dea863c65407 0x607f5f9815f515af 0x807289d8f9847407 0x4ab80d43269335ee 0xf78b56ada11ea641 0xc2306a55acfb4aaa julia> rand! ( r1 , A ) # Refill `A` with random numbers. 2\u00d73 Array{UInt64,2}: 0xf729352e2a72b541 0xe89948b5582a85f0 0x8a95ebd6aa34fcf4 0xc0c5a8df4c1b160f 0x8b5269ed6c790e08 0x930b89985ae0c865 People will get the same results in their own computers of the above lines. For more interfaces and usage examples, please refer to the manual pages of each RNG.","title":"Interface"},{"location":"man/basics/#empirical-statistical-testing","text":"Empirical statistical testing is very important for random number generation, because the theoretical mathematical analysis is insufficient to verify the performance of a random number generator. The famous and highly evaluated TestU01 library is chosen to test the RNGs in RandomNumbers.jl . TestU01 offers a collection of test suites, and Big Crush is the largest and most stringent test battery for empirical testing (which usually takes several hours to run). Big Crush has revealed a number of flaws of lots of well-used generators, even including the Mersenne Twister (or to be more exact, the dSFMT ) which is currently used in Base.Random as GLOBAL_RAND`. 1 This package chooses RNGTest.jl to use TestU01. The testing results are available on Benchmark page.","title":"Empirical Statistical Testing"},{"location":"man/basics/#conversion-to-float","text":"Besides the statistical flaws, popular generators often neglect the importance of converting unsigned integers to floating numbers. The most common situation is to convert an UInt to a Float64 which is uniformly distributed in $[0.0, 1.0)$. For example, neither the std::uniform_real_distribution in libstdc++ from gcc, libc++ from llvm, nor the standard library from MSVC has a correct performance, as they all have a non-zero probability for generating the max value which is an open bound and should not be produced. The cause is that a Float64 number in $[0.0, 1.0)$ has only 53 significand bits (52 explicitly stored), which means at least 11 bits of an UInt64 are abandoned when being converted to Float64 . If using the naive approach to multiply an UInt64 by $2^{-64}$, users may get 1.0, and the distribution is not good (although using $2^{-32}$ for an UInt32 is OK). In this package, we make use of the fact that the distribution of the least 52 bits can be the same in an UInt64 and a Float64 (if you are familiar with IEEE 754 this is easy to understand). An UInt64 will firstly be converted to a Float64 that is perfectly uniformly distributed in [1.0, 2.0), and then subtract one. This is a very fast approach, but not completely ideal, as the statistics of the least significant bits are affected. Due to rounding in the subtraction, the least significant bit of rand() is always 0, the second last is only at 25% a 1, the third last bit is at 37.5% chance a 1, the n-th last bit is at p=1/2-2^(-n) chance a 1. In practice, this only affects the last few bits, but holds for rand(Float32) as well as for rand(Float64) . the sampling is not from all floats in [0,1) but only from 2^23 (Float32) or 2^52 (Float64). The subset of floats which is sampled from is every second float in [1/2,1), every 4th in [1/4,1/2), so every 2n-th in [1/2n,1/n). The smallest positive float (but note that 0f0/0.0 is also possible) that is sampled is eps(Float32)=1.1920929f-7 (Float32) or eps(Float64)=2.220446049250313e-16 (Float64). The current default RNG in Base.Random library does the same thing, so it also causes some tricky problems. 2 To address some of these issues RandomNumbers.jl also provides randfloat() for Float16 , Float32 and Float64 , which has full entropy for all significant bits, i.e. 0 and 1 always occur at 50% chance samples from all floats in [2.7105054f-20,1) (Float32) and [2.710505431213761e-20,1) (Float64) and true [0,1) (Float16, including correct chances for subnormals) As the true chance to obtain a 0 in [0,1) for floats is effectively 0, it is practically also 0 for randfloat (except for Float16). is about 20% slower than rand , see #72 randfloat() is not based on the [1,2) minus one -approach but counts the leading zeros of a random UInt to obtain the correct chances for the exponent bits (which are 50% for 01111110 meaning [1/2,1) in float32, 25% for 01111101 meaning [1/4,1/2), etc.). This is combined with random UInt bits for the significand. rand fails bigcrush #6464 \u21a9 Least significant bit of rand() is always zero #16344 \u21a9","title":"Conversion to Float"},{"location":"man/benchmark/","text":"Benchmark This page includes the results of speed tests and big crush tests of several kinds of RNGs in this package. The data is produced on such a computer: julia > versioninfo () Julia Version 0.5.0 - rc0 + 0 Commit 633443 c ( 2016 - 08 - 02 00 : 53 UTC ) Platform Info : System : Linux ( x86_64 - redhat - linux ) CPU : Intel ( R ) Core ( TM ) i5 - 3470 CPU @ 3.20 GHz WORD_SIZE : 64 BLAS : libopenblas ( USE64BITINT DYNAMIC_ARCH NO_AFFINITY Sandybridge ) LAPACK : libopenblas64_ LIBM : libopenlibm LLVM : libLLVM - 3.7.1 ( ORCJIT , ivybridge ) All the benchmark scripts are in the benchmark directory, you can do the tests by yourself. !!!note All the data here is only for reference, and will be updated as this package is updated. Speed Test The speed test results are as following (the smaller is the better): and detailed in the table (sorted by speed): RNG Type Speed (ns/64 bits) RNG Type Speed (ns/64 bits) RNG Type Speed (ns/64 bits) Xoroshiro128Star 1.184 PCG_XSL_RR_128 2.646 Philox4x64 5.737 Xorshift128Plus 1.189 PCG_XSH_RS_64 2.738 Threefry4x64 5.965 Xoroshiro128Plus 1.393 PCG_XSH_RR_128 3.260 Threefry2x64 7.760 Xorshift128Star 1.486 PCG_XSL_RR_64 3.308 Philox2x32 9.698 PCG_RXS_M_XS_64 1.522 PCG_XSH_RS_128 3.373 Philox4x32 11.517 PCG_XSL_RR_RR_128 1.602 PCG_RXS_M_XS_32 3.420 Threefry4x32 12.241 Xorshift64 1.918 PCG_XSH_RR_64 3.580 Threefry2x32 16.253 BaseMT19937* 1.971 Xorshift1024Plus 3.725 ARS1x128 17.081 Xorshift64Star 2.000 Xorshift1024Star 3.748 ARS4x32 18.059 PCG_XSL_RR_RR_64 2.044 MT19937 4.229 AESNI1x128 18.304 PCG_RXS_M_XS_128 2.482 Philox2x64 5.161 AESNI4x32 29.770 * BaseMT19937 denotes to Base.Random.MersenneTwister . Big Crush Test 10 kinds of RNGs (which are worth considering) have been tested with Big Crush test batteries: RNG Type Speed (ns/64 bits) Total CPU time Failed Test(s)* AESNI1x128 18.304 04:14:22.19 ARS1x128 17.081 04:13:27.54 55 SampleCorr, k = 1 p-value = 7.0e-4 BaseMT19937 1.971 03:18:23.47 MT19937 4.229 03:32:59.06 36 Gap, r = 0 p-value = eps 80LinearComp, r = 0 p-value = 1-eps1 81 LinearComp, r = 29 p-value = 1-eps1 PCG_RXS_M_XS_64_64 1.522 03:20:07.97 PCG_XSH_RS_128_64 3.373 03:24:57.54 54 SampleMean, r = 10 0.9991 Philox2x64 5.737 03:28:52.27 35 Gap, r = 25 3.4e-4 Threefry2x64 5.965 03:37:53.53 Xoroshiro128Plus 1.393 03:33:16.51 Xorshift1024Star 3.748 03:39:15.19 *eps means a value < 1.0e-300, and eps1 means a value < 1.0e-15. It is interesting that BaseMT19937 passes all the tests when generating UInt64 (by generating two UInt32 with dSFMT). The PCG ones do not pass all the tests as the paper says, but the failures are just near the threshold. The RNG with best performance here is Xoroshiro128Plus , which passes all the tests and has an excellent speed.","title":"Benchmark"},{"location":"man/benchmark/#benchmark","text":"This page includes the results of speed tests and big crush tests of several kinds of RNGs in this package. The data is produced on such a computer: julia > versioninfo () Julia Version 0.5.0 - rc0 + 0 Commit 633443 c ( 2016 - 08 - 02 00 : 53 UTC ) Platform Info : System : Linux ( x86_64 - redhat - linux ) CPU : Intel ( R ) Core ( TM ) i5 - 3470 CPU @ 3.20 GHz WORD_SIZE : 64 BLAS : libopenblas ( USE64BITINT DYNAMIC_ARCH NO_AFFINITY Sandybridge ) LAPACK : libopenblas64_ LIBM : libopenlibm LLVM : libLLVM - 3.7.1 ( ORCJIT , ivybridge ) All the benchmark scripts are in the benchmark directory, you can do the tests by yourself. !!!note All the data here is only for reference, and will be updated as this package is updated.","title":"Benchmark"},{"location":"man/benchmark/#speed-test","text":"The speed test results are as following (the smaller is the better): and detailed in the table (sorted by speed): RNG Type Speed (ns/64 bits) RNG Type Speed (ns/64 bits) RNG Type Speed (ns/64 bits) Xoroshiro128Star 1.184 PCG_XSL_RR_128 2.646 Philox4x64 5.737 Xorshift128Plus 1.189 PCG_XSH_RS_64 2.738 Threefry4x64 5.965 Xoroshiro128Plus 1.393 PCG_XSH_RR_128 3.260 Threefry2x64 7.760 Xorshift128Star 1.486 PCG_XSL_RR_64 3.308 Philox2x32 9.698 PCG_RXS_M_XS_64 1.522 PCG_XSH_RS_128 3.373 Philox4x32 11.517 PCG_XSL_RR_RR_128 1.602 PCG_RXS_M_XS_32 3.420 Threefry4x32 12.241 Xorshift64 1.918 PCG_XSH_RR_64 3.580 Threefry2x32 16.253 BaseMT19937* 1.971 Xorshift1024Plus 3.725 ARS1x128 17.081 Xorshift64Star 2.000 Xorshift1024Star 3.748 ARS4x32 18.059 PCG_XSL_RR_RR_64 2.044 MT19937 4.229 AESNI1x128 18.304 PCG_RXS_M_XS_128 2.482 Philox2x64 5.161 AESNI4x32 29.770 * BaseMT19937 denotes to Base.Random.MersenneTwister .","title":"Speed Test"},{"location":"man/benchmark/#big-crush-test","text":"10 kinds of RNGs (which are worth considering) have been tested with Big Crush test batteries: RNG Type Speed (ns/64 bits) Total CPU time Failed Test(s)* AESNI1x128 18.304 04:14:22.19 ARS1x128 17.081 04:13:27.54 55 SampleCorr, k = 1 p-value = 7.0e-4 BaseMT19937 1.971 03:18:23.47 MT19937 4.229 03:32:59.06 36 Gap, r = 0 p-value = eps 80LinearComp, r = 0 p-value = 1-eps1 81 LinearComp, r = 29 p-value = 1-eps1 PCG_RXS_M_XS_64_64 1.522 03:20:07.97 PCG_XSH_RS_128_64 3.373 03:24:57.54 54 SampleMean, r = 10 0.9991 Philox2x64 5.737 03:28:52.27 35 Gap, r = 25 3.4e-4 Threefry2x64 5.965 03:37:53.53 Xoroshiro128Plus 1.393 03:33:16.51 Xorshift1024Star 3.748 03:39:15.19 *eps means a value < 1.0e-300, and eps1 means a value < 1.0e-15. It is interesting that BaseMT19937 passes all the tests when generating UInt64 (by generating two UInt32 with dSFMT). The PCG ones do not pass all the tests as the paper says, but the failures are just near the threshold. The RNG with best performance here is Xoroshiro128Plus , which passes all the tests and has an excellent speed.","title":"Big Crush Test"},{"location":"man/mersenne-twisters/","text":"Mersenne Twisters The Mersenne Twister 1 is so far the most widely used PRNG. Mersenne Twisters are taken as default random number generators of a great many of software systems, including the Julia language until the current 1.0 version. The most commonly used version of Mersenne Twisters is MT19937 , which has a very long period of $2^{19937}-1$ and passes numerous tests including the Diehard tests. However, it also has many flaws by today's standards. For the large period, MT19937 has to use a 2.5 KiB state buffer, which place a load on the memory caches. More severely, it cannot pass all the TestU01 statistical tests 2 , and the speed is not so fast. So it is not recommended in most situations. The MersenneTwisters in this package currently only provides one RNG: MT19937 . MT19937 can only produce UInt32 numbers as output. Its state is an array of 624 UInt32 numbers, so it takes 624 UInt32 s as seed. A default function is also provided to deal with one UInt32 as seed. Examples To use the Mersenne Twisters, firstly import the module: julia> using RandomNumbers . MersenneTwisters A certain sequence can be used to initialize an instance of MT19937: julia> seed = Tuple ( UInt32 ( i ) for i in 1 : 624 ); # This is a Tuple of 1..624 julia> r = MT19937 ( seed ); Since MT19937 is a RNG based on linear-feedback shift-register techniques, this approach is not recommended for an obivous reason: julia> rand ( r , UInt32 , 10 ) 10-element Array{UInt32,1}: 0x23864fee 0xdd51a593 0x20c049a2 0xde17a3df 0x20804931 0xde57a34c 0x20c049a0 0xde17a3dd 0x20804933 0xde57a34e The firstly generated numbers are so poorly random. This is because the most bits of states are zeros. So it is better to create a MT19937 in this way: julia> r = MT19937 (); In this case, all the 624 states will be filled with truly random numbers produced by RandomDevice . If someone needs the reproducibility, just save the state r.mt and use it for next time. An initialization function described in the original paper 1 is also implemented here, so the seed can also be just one UInt32 number (or an Integer whose least 32 bits will be truncated): julia> import Random julia> Random . seed! ( r , 0xabcdef12 ); julia> rand ( r , UInt32 , 10 ) 10-element Array{UInt32,1}: 0x986c5150 0xbb9e20f5 0xfb59a25a 0x189eb49c 0xbcca5395 0x48d9fdf5 0x3193f581 0xe0b6d080 0x63154ca2 0x72b28f0d Note that if you use one UInt32 number as seed, you will always get in a bias way. 3 Matsumoto M, Nishimura T. Mersenne twister: a 623-dimensionally equidistributed uniform pseudo-random number generator[J]. ACM Transactions on Modeling and Computer Simulation (TOMACS), 1998, 8(1): 3-30. doi: 10.1145/272991.272995 . \u21a9 \u21a9 L'Ecuyer P, Simard R. TestU01: AC library for empirical testing of random number generators[J]. ACM Transactions on Mathematical Software (TOMS), 2007, 33(4): 22. doi: 10.1145/1268776.1268777 \u21a9 C++ Seeding Surprises \u21a9","title":"Mersenne Twisters"},{"location":"man/mersenne-twisters/#mersenne-twisters","text":"The Mersenne Twister 1 is so far the most widely used PRNG. Mersenne Twisters are taken as default random number generators of a great many of software systems, including the Julia language until the current 1.0 version. The most commonly used version of Mersenne Twisters is MT19937 , which has a very long period of $2^{19937}-1$ and passes numerous tests including the Diehard tests. However, it also has many flaws by today's standards. For the large period, MT19937 has to use a 2.5 KiB state buffer, which place a load on the memory caches. More severely, it cannot pass all the TestU01 statistical tests 2 , and the speed is not so fast. So it is not recommended in most situations. The MersenneTwisters in this package currently only provides one RNG: MT19937 . MT19937 can only produce UInt32 numbers as output. Its state is an array of 624 UInt32 numbers, so it takes 624 UInt32 s as seed. A default function is also provided to deal with one UInt32 as seed.","title":"Mersenne Twisters"},{"location":"man/mersenne-twisters/#examples","text":"To use the Mersenne Twisters, firstly import the module: julia> using RandomNumbers . MersenneTwisters A certain sequence can be used to initialize an instance of MT19937: julia> seed = Tuple ( UInt32 ( i ) for i in 1 : 624 ); # This is a Tuple of 1..624 julia> r = MT19937 ( seed ); Since MT19937 is a RNG based on linear-feedback shift-register techniques, this approach is not recommended for an obivous reason: julia> rand ( r , UInt32 , 10 ) 10-element Array{UInt32,1}: 0x23864fee 0xdd51a593 0x20c049a2 0xde17a3df 0x20804931 0xde57a34c 0x20c049a0 0xde17a3dd 0x20804933 0xde57a34e The firstly generated numbers are so poorly random. This is because the most bits of states are zeros. So it is better to create a MT19937 in this way: julia> r = MT19937 (); In this case, all the 624 states will be filled with truly random numbers produced by RandomDevice . If someone needs the reproducibility, just save the state r.mt and use it for next time. An initialization function described in the original paper 1 is also implemented here, so the seed can also be just one UInt32 number (or an Integer whose least 32 bits will be truncated): julia> import Random julia> Random . seed! ( r , 0xabcdef12 ); julia> rand ( r , UInt32 , 10 ) 10-element Array{UInt32,1}: 0x986c5150 0xbb9e20f5 0xfb59a25a 0x189eb49c 0xbcca5395 0x48d9fdf5 0x3193f581 0xe0b6d080 0x63154ca2 0x72b28f0d Note that if you use one UInt32 number as seed, you will always get in a bias way. 3 Matsumoto M, Nishimura T. Mersenne twister: a 623-dimensionally equidistributed uniform pseudo-random number generator[J]. ACM Transactions on Modeling and Computer Simulation (TOMACS), 1998, 8(1): 3-30. doi: 10.1145/272991.272995 . \u21a9 \u21a9 L'Ecuyer P, Simard R. TestU01: AC library for empirical testing of random number generators[J]. ACM Transactions on Mathematical Software (TOMS), 2007, 33(4): 22. doi: 10.1145/1268776.1268777 \u21a9 C++ Seeding Surprises \u21a9","title":"Examples"},{"location":"man/pcg/","text":"PCG Family Permuted Congruential Generators (PCGs) are a family of RNGs which uses a linear congruential generator as the state-transition function, and uses permutation functions on tuples to produce output that is much more random than the RNG's internal state. 1 PCG Type Each PCG generator is available in four variants, based on how it applies the additive constant for its underlying LCG; the variations are: PCGStateOneseq (single stream): all instances use the same fixed constant, thus the RNG always somewhere in same sequence. PCGStateMCG (mcg): adds zero, resulting in a single stream and reduced period. PCGStateSetseq (specific stream): the constant can be changed at any time, selecting a different random sequence. PCGStateUnique (unique stream): the constant is based on the memory address of the object, thus every RNG has its own unique sequence. PCG Method Type PCG_XSH_RS : high xorshift, followed by a random shift. It's fast and is a good performer. PCG_XSH_RR : high xorshift, followed by a random rotate. It's fast and is a good performer. Slightly better statistically than PCG_XSH_RS . PCG_RXS_M_XS : fixed xorshift (to low bits), random rotate. The most statistically powerful generator, but all those steps make it slower than some of the others. (but in this package the benchmark shows it's even fast than PCG_XSH_RS , which is an current issue.) PCG_XSL_RR : fixed xorshift (to low bits), random rotate. Useful for 128-bit types that are split across two CPU registers. PCG_XSL_RR_RR : fixed xorshift (to low bits), random rotate (both parts). Useful for 128-bit types that are split across two CPU registers. Use this in need of an invertable 128-bit RNG. Interface and Examples An instance of PCG generator can be created by specify the state type, the output type, the method and seed. When seed is missing it is set to truly random numbers. The default output type is UInt64 , and the default method is PCG_XSH_RS . The seed will be converted to the internal state type (a kind of unsigned integer), and for PCGs with specific stream ( PCGStateSetseq ) the seed should be a Tuple of two Integer s. Note that not all parameter combinations are available (see PCG_LIST ). For example: julia> using RandomNumbers . PCG julia> PCGStateOneseq ( UInt64 , 1234567 ) # create a single stream PCG, specifying the output type and seed. PCGStateOneseq{UInt128,Val{:XSH_RS},UInt64}(0xa10d40ffc2b1e573e589b22b2450d1fd) julia> PCGStateUnique ( PCG_RXS_M_XS , 1234567 ); # unique stream PCG, specifying the method and seed. julia> PCGStateSetseq ( UInt32 , PCG_XSH_RR , ( 1234567 , 7654321 )) PCGStateSetseq{UInt64,Val{:XSH_RR},UInt32}(0xfc77de2cd901ff85, 0x0000000000e99763) bounded_rand is provided by this module, in which the bound is must an integer in the output type: julia> r = PCGStateOneseq ( 1234567 ) PCGStateOneseq{UInt128,Val{:XSH_RS},UInt64}(0xa10d40ffc2b1e573e589b22b2450d1fd) julia> [ bounded_rand ( r , UInt64 ( 100 )) for i in 1 : 6 ] 6-element Array{UInt64,1}: 0x0000000000000012 0x000000000000000a 0x000000000000002e 0x0000000000000049 0x0000000000000043 0x000000000000002b PCG also has an advance! function, used to advance the state of a PCG instance. julia> import Random julia> Random . seed! ( r , 1234567 ); julia> rand ( r , 4 ) 4-element Array{Float64,1}: 0.5716257379273757 0.9945058856417783 0.8886220302794352 0.08763836824057081 julia> advance! ( r , - 4 ); julia> rand ( r , 4 ) 4-element Array{Float64,1}: 0.5716257379273757 0.9945058856417783 0.8886220302794352 0.08763836824057081 O\u2019NEILL M E. PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation[J]. \u21a9","title":"PCG Family"},{"location":"man/pcg/#pcg-family","text":"Permuted Congruential Generators (PCGs) are a family of RNGs which uses a linear congruential generator as the state-transition function, and uses permutation functions on tuples to produce output that is much more random than the RNG's internal state. 1","title":"PCG Family"},{"location":"man/pcg/#pcg-type","text":"Each PCG generator is available in four variants, based on how it applies the additive constant for its underlying LCG; the variations are: PCGStateOneseq (single stream): all instances use the same fixed constant, thus the RNG always somewhere in same sequence. PCGStateMCG (mcg): adds zero, resulting in a single stream and reduced period. PCGStateSetseq (specific stream): the constant can be changed at any time, selecting a different random sequence. PCGStateUnique (unique stream): the constant is based on the memory address of the object, thus every RNG has its own unique sequence.","title":"PCG Type"},{"location":"man/pcg/#pcg-method-type","text":"PCG_XSH_RS : high xorshift, followed by a random shift. It's fast and is a good performer. PCG_XSH_RR : high xorshift, followed by a random rotate. It's fast and is a good performer. Slightly better statistically than PCG_XSH_RS . PCG_RXS_M_XS : fixed xorshift (to low bits), random rotate. The most statistically powerful generator, but all those steps make it slower than some of the others. (but in this package the benchmark shows it's even fast than PCG_XSH_RS , which is an current issue.) PCG_XSL_RR : fixed xorshift (to low bits), random rotate. Useful for 128-bit types that are split across two CPU registers. PCG_XSL_RR_RR : fixed xorshift (to low bits), random rotate (both parts). Useful for 128-bit types that are split across two CPU registers. Use this in need of an invertable 128-bit RNG.","title":"PCG Method Type"},{"location":"man/pcg/#interface-and-examples","text":"An instance of PCG generator can be created by specify the state type, the output type, the method and seed. When seed is missing it is set to truly random numbers. The default output type is UInt64 , and the default method is PCG_XSH_RS . The seed will be converted to the internal state type (a kind of unsigned integer), and for PCGs with specific stream ( PCGStateSetseq ) the seed should be a Tuple of two Integer s. Note that not all parameter combinations are available (see PCG_LIST ). For example: julia> using RandomNumbers . PCG julia> PCGStateOneseq ( UInt64 , 1234567 ) # create a single stream PCG, specifying the output type and seed. PCGStateOneseq{UInt128,Val{:XSH_RS},UInt64}(0xa10d40ffc2b1e573e589b22b2450d1fd) julia> PCGStateUnique ( PCG_RXS_M_XS , 1234567 ); # unique stream PCG, specifying the method and seed. julia> PCGStateSetseq ( UInt32 , PCG_XSH_RR , ( 1234567 , 7654321 )) PCGStateSetseq{UInt64,Val{:XSH_RR},UInt32}(0xfc77de2cd901ff85, 0x0000000000e99763) bounded_rand is provided by this module, in which the bound is must an integer in the output type: julia> r = PCGStateOneseq ( 1234567 ) PCGStateOneseq{UInt128,Val{:XSH_RS},UInt64}(0xa10d40ffc2b1e573e589b22b2450d1fd) julia> [ bounded_rand ( r , UInt64 ( 100 )) for i in 1 : 6 ] 6-element Array{UInt64,1}: 0x0000000000000012 0x000000000000000a 0x000000000000002e 0x0000000000000049 0x0000000000000043 0x000000000000002b PCG also has an advance! function, used to advance the state of a PCG instance. julia> import Random julia> Random . seed! ( r , 1234567 ); julia> rand ( r , 4 ) 4-element Array{Float64,1}: 0.5716257379273757 0.9945058856417783 0.8886220302794352 0.08763836824057081 julia> advance! ( r , - 4 ); julia> rand ( r , 4 ) 4-element Array{Float64,1}: 0.5716257379273757 0.9945058856417783 0.8886220302794352 0.08763836824057081 O\u2019NEILL M E. PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation[J]. \u21a9","title":"Interface and Examples"},{"location":"man/random123/","text":"Random123 Family Random123 is a library of \"counter-based\" random number generators (CBRNGs), developed by D.E.Shaw Research 1 . Counter-based means the RNGs in this family can produce the $\\mathrm{N}^\\textrm{th}$ number by applying a stateless mixing function to the counter $\\mathrm{N}$, instead of the conventional approach of using $\\mathrm{N}$ iterations of a stateful transformation. The current version of Random123 in this package is 1.09, and there are four kinds of RNGs: Threefry , Philox , AESNI , ARS . The original paper 1 says all the RNGs in Random123 can pass Big Crush in TestU01, but in the benchmark we did, ARS1x128 and Philox2x64 have a slight failure. Random123 RNGs All the RNG types in Random123 have a property ctr1 , which denotes to its first counter , and some of them have ctr2 for the second counter . The suffix '-1x', '-2x' and '-4x' indicates how many numbers will be generated per time. The first one or two or four properties of a RNG type in Random123 are always x (or x1 , x2 , etc.), which denote to the produced numbers. Threefry Threefry is a non-cryptographic adaptation of the Threefish block cipher from the Skein Hash Function . In this package, there are two Type s of Threefry : Threefry4x and Threefry2x . Besides the output type T , there is another parameter R , which denotes to the number of rounds, and must be at least 1 and no more than 32. With 20 rounds (by default), Threefry has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance. They both support UInt32 and UInt64 output. Philox Philox uses a Feistel network and integer multiplication. Philox also has two Type s: Philox4x and Philox2x . The number of rounds must be at least 1 and no more than 16. With 10 rounds (by default), Philox2x32 has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance. They both support UInt32 and UInt64 output. AESNI AESNI uses the Advanced Encryption Standard (AES) New Instruction, available on certain modern x86 processors (some models of Intel Westmere and Sandy Bridge, and AMD Interlagos, as of 2011). AESNI CBRNGs can operate on UInt128 type. AESNI has two Type s: AESNI1x and AESNI4x . AESNI4x only internally converts UInt128 to UInt32 . ARS ARS (Advanced Randomization System) is a non-cryptographic simplification of AESNI . ARS has two Type s: ARS1x and ARS4x . ARS4x only internally converts UInt128 to UInt32 . Note that although it uses some cryptographic primitives, ARS1x uses a cryptographically weak key schedule and is not suitable for cryptographic use. The number of rounds must be at least 1 and no more than 10, and is 7 by default. Examples For detailed usage of each RNG, please refer to the library docs . To use Random123, firstly import the module: julia > using RandomNumbers . Random123 Take Philox4x64 for example: julia> r = Philox4x (); # will output UInt64 by default, and two seed integers are truly randomly produced. julia> r = Philox4x (( 0x12345678abcdef01 , 0x10fedcba87654321 )); # specify the seed. julia> r = Philox4x ( UInt64 , ( 0x12345678abcdef01 , 0x10fedcba87654321 )); # specify both the output type and seed. julia> rand ( r , NTuple { 4 , UInt64 }) (0x00d626ee85b7d2ed, 0xa57b4af2b68c655e, 0x82dad737de789de2, 0x8d390e05845e6c4d) julia> set_counter! ( r , 123 ); # update the counter manually. julia> rand ( r , UInt64 , 4 ) 4-element Array{UInt64,1}: 0x56a4eb812faa9cd7 0xf3d3464a49b23b56 0xda5a5824aea0b2bb 0x097a8d117a2bb20a julia> set_counter! ( r , 0 ); julia> rand ( r , NTuple { 4 , UInt64 }) (0x00d626ee85b7d2ed, 0xa57b4af2b68c655e, 0x82dad737de789de2, 0x8d390e05845e6c4d) John K. Salmon, Mark A. Moraes, Ron O. Dror, and David E. Shaw, \"Parallel Random Numbers: As Easy as 1, 2, 3,\" Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis (SC11), New York, NY: ACM, 2011. doi: 10.1145/2063384.2063405 \u21a9 \u21a9","title":"Random123 Family"},{"location":"man/random123/#random123-family","text":"Random123 is a library of \"counter-based\" random number generators (CBRNGs), developed by D.E.Shaw Research 1 . Counter-based means the RNGs in this family can produce the $\\mathrm{N}^\\textrm{th}$ number by applying a stateless mixing function to the counter $\\mathrm{N}$, instead of the conventional approach of using $\\mathrm{N}$ iterations of a stateful transformation. The current version of Random123 in this package is 1.09, and there are four kinds of RNGs: Threefry , Philox , AESNI , ARS . The original paper 1 says all the RNGs in Random123 can pass Big Crush in TestU01, but in the benchmark we did, ARS1x128 and Philox2x64 have a slight failure.","title":"Random123 Family"},{"location":"man/random123/#random123-rngs","text":"All the RNG types in Random123 have a property ctr1 , which denotes to its first counter , and some of them have ctr2 for the second counter . The suffix '-1x', '-2x' and '-4x' indicates how many numbers will be generated per time. The first one or two or four properties of a RNG type in Random123 are always x (or x1 , x2 , etc.), which denote to the produced numbers.","title":"Random123 RNGs"},{"location":"man/random123/#threefry","text":"Threefry is a non-cryptographic adaptation of the Threefish block cipher from the Skein Hash Function . In this package, there are two Type s of Threefry : Threefry4x and Threefry2x . Besides the output type T , there is another parameter R , which denotes to the number of rounds, and must be at least 1 and no more than 32. With 20 rounds (by default), Threefry has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance. They both support UInt32 and UInt64 output.","title":"Threefry"},{"location":"man/random123/#philox","text":"Philox uses a Feistel network and integer multiplication. Philox also has two Type s: Philox4x and Philox2x . The number of rounds must be at least 1 and no more than 16. With 10 rounds (by default), Philox2x32 has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance. They both support UInt32 and UInt64 output.","title":"Philox"},{"location":"man/random123/#aesni","text":"AESNI uses the Advanced Encryption Standard (AES) New Instruction, available on certain modern x86 processors (some models of Intel Westmere and Sandy Bridge, and AMD Interlagos, as of 2011). AESNI CBRNGs can operate on UInt128 type. AESNI has two Type s: AESNI1x and AESNI4x . AESNI4x only internally converts UInt128 to UInt32 .","title":"AESNI"},{"location":"man/random123/#ars","text":"ARS (Advanced Randomization System) is a non-cryptographic simplification of AESNI . ARS has two Type s: ARS1x and ARS4x . ARS4x only internally converts UInt128 to UInt32 . Note that although it uses some cryptographic primitives, ARS1x uses a cryptographically weak key schedule and is not suitable for cryptographic use. The number of rounds must be at least 1 and no more than 10, and is 7 by default.","title":"ARS"},{"location":"man/random123/#examples","text":"For detailed usage of each RNG, please refer to the library docs . To use Random123, firstly import the module: julia > using RandomNumbers . Random123 Take Philox4x64 for example: julia> r = Philox4x (); # will output UInt64 by default, and two seed integers are truly randomly produced. julia> r = Philox4x (( 0x12345678abcdef01 , 0x10fedcba87654321 )); # specify the seed. julia> r = Philox4x ( UInt64 , ( 0x12345678abcdef01 , 0x10fedcba87654321 )); # specify both the output type and seed. julia> rand ( r , NTuple { 4 , UInt64 }) (0x00d626ee85b7d2ed, 0xa57b4af2b68c655e, 0x82dad737de789de2, 0x8d390e05845e6c4d) julia> set_counter! ( r , 123 ); # update the counter manually. julia> rand ( r , UInt64 , 4 ) 4-element Array{UInt64,1}: 0x56a4eb812faa9cd7 0xf3d3464a49b23b56 0xda5a5824aea0b2bb 0x097a8d117a2bb20a julia> set_counter! ( r , 0 ); julia> rand ( r , NTuple { 4 , UInt64 }) (0x00d626ee85b7d2ed, 0xa57b4af2b68c655e, 0x82dad737de789de2, 0x8d390e05845e6c4d) John K. Salmon, Mark A. Moraes, Ron O. Dror, and David E. Shaw, \"Parallel Random Numbers: As Easy as 1, 2, 3,\" Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis (SC11), New York, NY: ACM, 2011. doi: 10.1145/2063384.2063405 \u21a9 \u21a9","title":"Examples"},{"location":"man/xorshifts/","text":"Xorshift Family Xorshift family is a class of PRNGs based on linear transformation that takes the exclusive or of a number with a bit-shifted version of itself 1 . They are extremely fast on mordern computer architectures, and are very suitable for non-cryptographically-secure use. The suffix -Star and -Plus in the RNG names denote to two classes of improved RNGs 2 3 , which make it to pass Big Crush in TestU01. -Star RNGs are obtained by scrambling the output of a normal Xorshift generator with a 64-bit invertible multiplier, while -Plus RNGs return the sum of two consecutive output of a Xorshift generator. In this package there are four series of RNG types: Xorshift64 and Xorshift64Star : They have a period of $2^{64}$, but not recommended because 64 bits of state are not enough for any serious purpose. Xorshift128 , Xorshift128Star and Xorshift128Plus : They have a period of $2^{128}$. Xorshift128Plus is presently used in the JavaScript engines of Chrome, Firefox and Safari. Xorshift1024 , Xorshift1024Star and Xorshift1024Plus : They have a long period of $2^{1024}$, and takes some more space for storing the state. If you are running large-scale parallel simulations, it's a good choice to use Xorshift1024Star . Xoroshiro128 , Xoroshiro128Star and Xoroshiro128Plus : The successor to Xorshift128 series. They make use of a carefully handcrafted shift/rotate-based linear transformation, resulting in a significant improvement in speed and in statistical quality. Therefore, Xoroshiro128Plus is the current best suggestion for replacing other low-quality generators. All the RNG types produce UInt64 numbers, if you have need for other output type, see WrappedRNG . Examples The usage of Xorshift family is very simple and common: julia> using RandomNumbers . Xorshifts julia> r = Xoroshiro128Plus (); # create a RNG with truly random seed. julia> r = Xoroshiro128Plus ( 0x1234567890abcdef ) # with a certain seed. Note that the seed must be non-zero. Xoroshiro128Plus(0xe7eb72d97b4beac6, 0x9b86d56534ba1f9e) julia> rand ( r ) 0.14263790854661185 julia> rand ( r , UInt32 ) 0x0a0315b3 Marsaglia G. Xorshift rngs[J]. Journal of Statistical Software, 2003, 8(14): 1-6. doi: 10.18637/jss.v008.i14 \u21a9 Vigna S. An experimental exploration of Marsaglia's xorshift generators, scrambled[J]. arXiv preprint arXiv:1402.6246 , 2014. \u21a9 Vigna S. Further scramblings of Marsaglia's xorshift generators[J]. arXiv preprint arXiv:1404.0390 , 2014. \u21a9","title":"Xorshift Family"},{"location":"man/xorshifts/#xorshift-family","text":"Xorshift family is a class of PRNGs based on linear transformation that takes the exclusive or of a number with a bit-shifted version of itself 1 . They are extremely fast on mordern computer architectures, and are very suitable for non-cryptographically-secure use. The suffix -Star and -Plus in the RNG names denote to two classes of improved RNGs 2 3 , which make it to pass Big Crush in TestU01. -Star RNGs are obtained by scrambling the output of a normal Xorshift generator with a 64-bit invertible multiplier, while -Plus RNGs return the sum of two consecutive output of a Xorshift generator. In this package there are four series of RNG types: Xorshift64 and Xorshift64Star : They have a period of $2^{64}$, but not recommended because 64 bits of state are not enough for any serious purpose. Xorshift128 , Xorshift128Star and Xorshift128Plus : They have a period of $2^{128}$. Xorshift128Plus is presently used in the JavaScript engines of Chrome, Firefox and Safari. Xorshift1024 , Xorshift1024Star and Xorshift1024Plus : They have a long period of $2^{1024}$, and takes some more space for storing the state. If you are running large-scale parallel simulations, it's a good choice to use Xorshift1024Star . Xoroshiro128 , Xoroshiro128Star and Xoroshiro128Plus : The successor to Xorshift128 series. They make use of a carefully handcrafted shift/rotate-based linear transformation, resulting in a significant improvement in speed and in statistical quality. Therefore, Xoroshiro128Plus is the current best suggestion for replacing other low-quality generators. All the RNG types produce UInt64 numbers, if you have need for other output type, see WrappedRNG .","title":"Xorshift Family"},{"location":"man/xorshifts/#examples","text":"The usage of Xorshift family is very simple and common: julia> using RandomNumbers . Xorshifts julia> r = Xoroshiro128Plus (); # create a RNG with truly random seed. julia> r = Xoroshiro128Plus ( 0x1234567890abcdef ) # with a certain seed. Note that the seed must be non-zero. Xoroshiro128Plus(0xe7eb72d97b4beac6, 0x9b86d56534ba1f9e) julia> rand ( r ) 0.14263790854661185 julia> rand ( r , UInt32 ) 0x0a0315b3 Marsaglia G. Xorshift rngs[J]. Journal of Statistical Software, 2003, 8(14): 1-6. doi: 10.18637/jss.v008.i14 \u21a9 Vigna S. An experimental exploration of Marsaglia's xorshift generators, scrambled[J]. arXiv preprint arXiv:1402.6246 , 2014. \u21a9 Vigna S. Further scramblings of Marsaglia's xorshift generators[J]. arXiv preprint arXiv:1404.0390 , 2014. \u21a9","title":"Examples"}]}